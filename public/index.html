<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- NEW: Mobile viewport tag -->
    <title>17 Leveling – V1.3 BETA</title>
    <!-- Import MedievalSharp Font -->
    <link href="https://fonts.googleapis.com/css2?family=MedievalSharp&display=swap" rel="stylesheet">
    <style>
      /* Global Reset and Base Styles */
      html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
      body {
        font-family: 'MedievalSharp', cursive;
        background: #111;
        color: #eaeaea;
      }
  
      /* Enlarged Game Container */
      #gameContainer {
        margin: 0 auto;
        width: 1000px;
        height: 600px;
        position: relative;
        border: 2px solid #444;
        background: #555;
      }
  
      /* Global Announcement Overlay */
      #globalAnnouncement {
        position: absolute;
        top: 0;
        width: 100%;
        text-align: center;
        z-index: 120;
        display: none;
        pointer-events: none;
      }
  
      /* UI Overlay for HUD */
      #uiOverlay {
        position: absolute;
        width: 100%;
        top: 0;
        left: 0;
        z-index: 10;
        text-align: center;
        pointer-events: auto;
      }
  
      /* Cooldown Display */
      #cooldownDisplay {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(0,0,0,0.7);
        padding: 10px;
        border-radius: 4px;
        font-size: 14px;
        color: #fff;
        z-index: 50;
        pointer-events: auto;
      }
  
      /* Big Notification */
      #bigNotification {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.85);
        color: #fff;
        font-size: 32px;
        padding: 20px 40px;
        border-radius: 4px;
        display: none;
        z-index: 90;
        pointer-events: auto;
      }
  
      /* Chat System Styles */
      #chatContainer {
        position: fixed;
        bottom: 10px;
        right: 10px;
        width: 300px;
        max-height: 200px;
        background: rgba(0,0,0,0.85);
        color: #fff;
        font-size: 14px;
        padding: 5px;
        overflow-y: auto;
        border: 1px solid #444;
        z-index: 95;
        border-radius: 4px;
        display: none;
        pointer-events: auto;
      }
      #chatInput {
        width: 90%;
        padding: 5px;
        border: 1px solid #444;
        outline: none;
        margin-top: 5px;
        border-radius: 4px;
        background: #222;
        color: #fff;
      }
      /* Chat Toggle Button & Badge */
      #chatToggle {
        position: fixed;
        bottom: 10px;
        right: 320px;
        z-index: 100;
        padding: 10px 15px;
        font-size: 16px;
        cursor: pointer;
        background: #27ae60;
        color: #fff;
        border: none;
        border-radius: 4px;
        pointer-events: auto;
      }
      #chatBadge {
        position: absolute;
        top: -5px;
        right: -5px;
        background: red;
        color: #fff;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        text-align: center;
        font-size: 12px;
        line-height: 20px;
        display: none;
        pointer-events: auto;
      }
  
      /* Admin Panel Toggle Button (visible for admins) */
      #adminToggle {
        position: fixed;
        bottom: 10px;
        left: 10px;
        z-index: 105;
        padding: 10px 15px;
        font-size: 16px;
        cursor: pointer;
        background: #e67e22;
        color: #fff;
        border: none;
        border-radius: 4px;
        display: none;
        pointer-events: auto;
      }
  
      /* Controls Overlay */
      #controlsOverlay {
        position: fixed;
        top: 50px;
        right: 10px;
        width: 280px;
        background: rgba(0,0,0,0.9);
        border: 2px solid #444;
        padding: 10px;
        z-index: 80;
        border-radius: 4px;
        display: none;
        font-size: 14px;
        pointer-events: auto;
      }
      #controlsOverlay h2 {
        margin: 0 0 10px;
        font-size: 20px;
        text-align: center;
      }
      #controlsOverlay ul {
        list-style: none;
        padding: 0;
      }
      #controlsOverlay li {
        margin-bottom: 8px;
        line-height: 1.4;
      }
      #controlsToggle {
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 110;
        padding: 8px 12px;
        background: #27ae60;
        color: #fff;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        pointer-events: auto;
      }
  
      /* Account Overlay and Forms */
      #accountOverlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 1000px;
        height: 600px;
        background: rgba(0,0,0,0.9);
        z-index: 120;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        pointer-events: auto;
      }
      #accountOverlay .mainOptions {
        display: flex;
        gap: 20px;
        margin-bottom: 20px;
        pointer-events: auto;
      }
      #accountOverlay button {
        padding: 10px 20px;
        font-size: 20px;
        cursor: pointer;
        border: none;
        border-radius: 4px;
        background: #007bff;
        color: #fff;
        transition: background 0.3s;
        pointer-events: auto;
      }
      #accountOverlay button:hover {
        background: #0056b3;
      }
      #createAccountForm, #loginForm {
        display: none;
        flex-direction: column;
        align-items: center;
        gap: 10px;
        margin-top: 20px;
        pointer-events: auto;
      }
      #createAccountForm input, #loginForm input, #createAccountForm select {
        padding: 10px;
        font-size: 18px;
      }
      #accountOverlay .backBtn {
        margin-top: 10px;
        padding: 5px 10px;
        font-size: 16px;
        cursor: pointer;
        border: none;
        background: #555;
        color: #fff;
        border-radius: 4px;
        pointer-events: auto;
      }

      /* NEW: Ensure both Create Account and Log In submit buttons have same width */
      #createAccountForm button,
      #loginForm button {
          width: 250px;  /* fixed width for consistency */
      }
  
      /* Class Selection Bar */
      #classSelectionBar {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        background: rgba(0,0,0,0.9);
        z-index: 50;
        display: none;
        justify-content: center;
        gap: 20px;
        padding: 10px 0;
        pointer-events: auto;
      }
      .classBtn {
        background: #007bff;
        color: #fff;
        border: none;
        border-radius: 4px;
        font-size: 20px;
        padding: 10px 20px;
        cursor: pointer;
        transition: background 0.3s;
        position: relative;
        pointer-events: auto;
      }
      .classBtn:hover {
        background: #0056b3;
      }
      #monarchBtn {
        background: gold;
        color: #222;
      }
      #monarchBtn::before, #monarchBtn::after {
        content: "👑";
        position: absolute;
        top: -20px;
        font-size: 20px;
      }
      #monarchBtn::before {
        left: -20px;
      }
      #monarchBtn::after {
        right: -20px;
      }
  
      /* Monarch Unlock Overlay */
      #monarchOverlay {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 400px;
        background: rgba(0,0,0,0.95);
        z-index: 130;
        display: none;
        flex-direction: column;
        align-items: center;
        padding: 20px;
        border: 2px solid red;
        border-radius: 8px;
        pointer-events: auto;
      }
      #monarchOverlay h2 {
        color: red;
        margin-bottom: 10px;
        font-size: 20px;
      }
      #monarchOverlay input {
        padding: 10px;
        font-size: 18px;
        margin-bottom: 10px;
        width: 80%;
      }
      #monarchOverlay button {
        padding: 8px 16px;
        font-size: 18px;
        cursor: pointer;
        pointer-events: auto;
      }
      #monarchOverlay .closeBtn {
        position: absolute;
        top: 5px;
        right: 10px;
        background: transparent;
        border: none;
        color: red;
        font-size: 24px;
        cursor: pointer;
        pointer-events: auto;
      }
  
      /* Dungeon Panel */
      #dungeonPanel {
        position: absolute;
        width: 300px;
        background: rgba(30,30,30,0.95);
        padding: 10px;
        border: 2px solid #555;
        z-index: 70;
        display: none;
        cursor: move;
        pointer-events: auto;
        opacity: 0;
        transform: scale(0.95);
        transition: opacity 0.25s cubic-bezier(.4,0,.2,1), transform 0.25s cubic-bezier(.4,0,.2,1);
        max-height: 400px; /* NEW: Limit panel height for scroll */
        overflow: visible;
      }
      #dungeonPanel.open {
        opacity: 1;
        transform: scale(1);
        pointer-events: auto;
      }
      #dungeonPanel ul {
        list-style: none;
        padding: 0;
        max-height: 300px; /* NEW: Limit dungeon list height */
        overflow-y: auto;  /* NEW: Enable vertical scroll */
        scrollbar-width: thin; /* For Firefox */
        scrollbar-color: #888 #222;
      }
      #dungeonPanel ul::-webkit-scrollbar {
        width: 8px;
      }
      #dungeonPanel ul::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 4px;
      }
      #dungeonPanel ul::-webkit-scrollbar-track {
        background: #222;
      }
      #dungeonPanel h1 {
        margin: 5px 0;
        text-align: center;
        font-size: 26px;
      }
      #dungeonPanel ul {
        list-style: none;
        padding: 0;
      }
      #dungeonPanel li {
        margin: 3px 0;
        padding: 3px;
        border: 1px solid #777;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 14px;
      }
      #dungeonPanel li:hover {
        background: #333;
      }
      #dungeonPanel button {
        margin-top: 5px;
        padding: 5px 10px;
        font-size: 14px;
        cursor: pointer;
        pointer-events: auto;
      }
  
      /* Admin Panel - Completely Revamped */
      #adminPanel {
        position: fixed;
        top: 10%;
        right: 5%;
        width: 400px;
        background: linear-gradient(135deg, #444, #222);
        border: 2px solid #27ae60;
        border-radius: 8px;
        z-index: 140;
        display: none;
        resize: both;
        overflow: auto;
        color: #eaeaea;
        padding: 20px;
        box-shadow: 0 6px 20px rgba(0,0,0,0.8);
      }
      #adminPanel h2 {
        margin-top: 0;
        background: #27ae60;
        padding: 14px;
        border-top-left-radius: 6px;
        border-top-right-radius: 6px;
        text-align: center;
        font-size: 24px;
        color: #fff;
      }
      #adminPanel .playerList {
        list-style: none;
        margin: 0;
        padding: 10px;
      }
      #adminPanel .playerList li {
        margin: 10px 0;
        padding: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: #333;
        border-radius: 4px;
      }
      #adminPanel .playerList li span {
        font-size: 16px;
      }
      #adminPanel button {
        padding: 6px 12px;
        font-size: 14px;
        cursor: pointer;
        background: #007bff;
        border: none;
        color: #fff;
        border-radius: 4px;
        transition: background 0.3s;
      }
      #adminPanel button:hover {
        background: #0056b3;
      }
      #adminPanel .closeBtn {
        position: absolute;
        top: 5px;
        right: 10px;
        background: transparent;
        border: none;
        color: #fff;
        font-size: 26px;
        cursor: pointer;
        pointer-events: auto;
      }
      /* Global Announcement Section in Admin Panel */
      #adminAnnouncement {
        margin-top: 20px;
        padding: 10px;
        background: #555;
        border-radius: 4px;
      }
      #adminAnnouncement input[type="text"] {
        width: 100%;
        padding: 6px;
        margin-bottom: 8px;
        border: 1px solid #777;
        border-radius: 4px;
      }
      #adminAnnouncement input[type="color"],
      #adminAnnouncement select {
        padding: 4px;
        margin-right: 8px;
        border: 1px solid #777;
        border-radius: 4px;
      }
      #adminAnnouncement button {
        padding: 6px 12px;
        font-size: 14px;
        cursor: pointer;
        background: #27ae60;
        border: none;
        color: #fff;
        border-radius: 4px;
      }

      /* NEW: Shutdown Overlay Styles */
      #shutdownOverlay {
        position: fixed;
        top: 0; left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.9);
        z-index: 2000;
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        color: #fff;
      }
      #shutdownOverlay h1 {
        font-size: 48px;
        margin-bottom: 20px;
      }
      #shutdownOverlay p {
        font-size: 18px;
      }
  
      /* Class Panel */
      #classPanel {
        position: fixed;
        top: 20%;
        left: 10px;
        width: 280px;
        height: auto;
        background: linear-gradient(135deg, #3498db, #2980b9);
        border: none;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.5);
        z-index: 140;
        display: none;
        resize: both;
        overflow: auto;
        color: #fff;
        padding-bottom: 10px;
        pointer-events: auto;
      }
      #classPanel h2 {
        margin: 0;
        padding: 15px;
        background: rgba(0,0,0,0.3);
        border-top-left-radius: 8px;
        border-top-right-radius: 8px;
        text-align: center;
        font-size: 22px;
      }
      #classPanel .closeBtn {
        position: absolute;
        top: 5px;
        right: 10px;
        background: transparent;
        border: none;
        color: #fff;
        font-size: 24px;
        cursor: pointer;
        pointer-events: auto;
      }
      #classPanel button {
        width: 90%;
        margin: 10px auto;
        display: block;
        padding: 10px;
        background: #fff;
        color: #2980b9;
        border: 2px solid #fff;
        border-radius: 4px;
        font-size: 18px;
        cursor: pointer;
        transition: background 0.3s, color 0.3s;
        pointer-events: auto;
      }
      #classPanel button:hover {
        background: #2980b9;
        color: #fff;
      }
  
      /* Canvas Styling */
      canvas {
        display: block;
        margin: 0 auto;
        background: #333;
      }

      /* Shop Panel */
      #shopPanel {
        display: none;
        position: fixed;
        left: calc(50% - 150px);
        top: calc(50% - 150px);
        width: 320px;
        background: linear-gradient(145deg, #DAA520, #B8860B);
        border: 2px solid #DAA520;
        border-radius: 8px;
        z-index: 130;
        padding: 15px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        opacity: 0;
        transform: scale(0.95);
        transition: opacity 0.25s cubic-bezier(.4,0,.2,1), transform 0.25s cubic-bezier(.4,0,.2,1);
      }
      #shopPanel.open {
        opacity: 1;
        transform: scale(1);
        pointer-events: auto;
      }
      #shopPanel h1 {
        text-align: center;
        font-size: 32px;
        color: #fff;
        margin-bottom: 15px;
        font-family: 'MedievalSharp', cursive;
      }
      #shopItemList {
        list-style: none;
        padding: 0;
        color: #fff;
        font-family: 'MedievalSharp', cursive;
      }
      #shopItemList li {
        margin-bottom: 12px;
        padding: 5px;
        border-bottom: 1px solid #444;
      }
      #shopItemList span {
        display: block;
        margin-bottom: 5px;
      }
      #shopPanel button {
        background: linear-gradient(145deg, #27ae60, #1e8f4d);
        border: none;
        color: #fff;
        padding: 8px 15px;
        border-radius: 6px;
        font-size: 16px;
        cursor: pointer;
        transition: background 0.3s;
      }
      #shopPanel button:hover {
        background: linear-gradient(145deg, #1e8f4d, #27ae60);
      }

      /* Mobile Controls Styles */
      #mobileControls {
        display: none;
      }

      @media (max-width: 768px) {
        /* Make game container responsive and centered vertically */
        #gameContainer {
            width: 95vw;
            max-width: 1000px;
            height: auto;
            max-height: 90vh;
            margin: 5vh auto;
        }
        /* Adjust Account Overlay for mobile */
        #accountOverlay {
            width: 95vw;
            height: 95vh;
            left: 2.5vw;
            top: 2.5vh;
        }
        /* Enhance Mobile Controls */
        #mobileControls {
            display: flex;
            position: fixed;
            bottom: 10px;
            left: 10px;
            right: 10px;
            justify-content: space-between;
            z-index: 200;
            /* ensure controls are below overlays like login */
        }
        #dpad,
        #actionButtons {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        #mobileControls button {
            width: 50px;
            height: 50px;
            font-size: 16px;
            border-radius: 6px;
            border: none;
            background: rgba(39,174,96,0.8);
            color: #fff;
        }
      }

      /* NEW: Event Panel Styles */
      #eventPanel {
        position: fixed;
        bottom: 50px;
        left: 10px;
        width: 300px;
        background: linear-gradient(135deg, #444, #222);
        border: 2px solid #27ae60;
        border-radius: 8px;
        z-index: 150;
        padding: 20px;
        display: none;
        resize: both;
        overflow: auto;
        color: #eaeaea;
      }
      #eventPanel h2 {
        margin: 0;
        padding: 14px;
        background: #27ae60;
        border-top-left-radius: 6px;
        border-top-right-radius: 6px;
        text-align: center;
        font-size: 24px;
        color: #fff;
      }
      #eventPanel .closeBtn {
        position: absolute;
        top: 5px;
        right: 10px;
        background: transparent;
        border: none;
        color: #fff;
        font-size: 26px;
        cursor: pointer;
      }
      #eventPanel button {
        width: 100%;
        padding: 10px;
        margin-top: 10px;
        border: none;
        border-radius: 4px;
        background: #27ae60;
        color: #fff;
        font-size: 18px;
        cursor: pointer;
        transition: background 0.3s;
      }
      #eventPanel button:hover {
        background: #1e8f4d;
      }

      /* Revised Quest Panel Styles */
      #questPanel {
          background: linear-gradient(135deg, #1a1a1a, #333);
          border: 2px solid #FFD700; /* golden border */
          border-radius: 12px;
          padding: 25px;
          font-family: 'MedievalSharp', cursive;
          color: #FFD700;
          box-shadow: 0 4px 10px rgba(0,0,0,0.8);
      }
      #questPanel h2 {
          font-size: 28px;
          margin-bottom: 10px;
          text-align: center;
          text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
      }
      #questPanel .questActions button {
          background: #FFD700;
          border: none;
          color: #111;
          padding: 10px 15px;
          margin: 5px;
          border-radius: 6px;
          font-size: 16px;
          cursor: pointer;
          transition: background 0.3s;
      }
      #questPanel .questActions button:hover {
          background: #e6b800;
      }

      /* Revised NPC Dialogue Styles */
      #npcDialogue {
          position: fixed;
          top: 50%;
          right: 50%;
          transform: translate(50%, -50%);
          width: 350px;
          background: linear-gradient(135deg, #444, #666);
          border: 3px solid #FFD700;
          border-radius: 12px;
          padding: 25px;
          z-index: 2100;
          display: none;
          font-family: 'MedievalSharp', cursive;
          color: #fff;
          box-shadow: 0 6px 20px rgba(0,0,0,0.8);
      }
      #npcDialogue p {
          font-size: 18px;
          margin-bottom: 15px;
      }
      #npcDialogue button {
          background: #FFD700;
          border: none;
          padding: 10px 15px;
          border-radius: 6px;
          color: #111;
          font-size: 16px;
          cursor: pointer;
          transition: background 0.3s;
          margin-right: 10px;
      }
      #npcDialogue button:hover {
          background: #e6b800;
      }

      /* NEW: NPC Dialogue Overlay */
      #npcDialogue {
        position: fixed;
        top: 50px;
        right: 50px;
        width: 300px;
        background: rgba(0,0,0,0.95);
        border: 2px solid gold;
        border-radius: 8px;
        padding: 20px;
        z-index: 2100;
        display: none;
        font-family: 'MedievalSharp', cursive;
        color: #fff;
      }
      #npcDialogue button {
        margin: 5px;
        padding: 8px 12px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }
      /* UPDATED: Quest Panel Styles */
      #questPanel {
        position: fixed;
        top: 100px;
        left: 50%;
        transform: translateX(-50%);
        width: 400px;
        background: rgba(50,50,50,0.95);
        border: 2px solid gold;
        border-radius: 8px;
        padding: 20px;
        z-index: 2100;
        display: none;
        font-family: 'MedievalSharp', cursive;
        color: #fff;
      }
      #questPanel h2 {
        margin-top: 0;
        text-align: center;
        color: gold;
      }
      #questPanel .questObjectives p {
        margin: 10px 0;
      }
      #questPanel .questActions {
        text-align: center;
        margin-top: 15px;
      }
      #questPanel .redeemableClasses {
        margin-top: 20px;
      }
      #questPanel .redeemableClasses h3 {
        text-align: center;
        color: gold;
      }
      #questPanel .redeemableClasses #redeemedList {
        text-align: center;
      }
      /* NEW: Redeemed Classes List */
      #redeemedClasses {
        position: fixed;
        bottom: 20px;
        left: 20px;
        background: rgba(0,0,0,0.9);
        border: 2px solid gold;
        border-radius: 8px;
        padding: 10px;
        z-index: 2100;
        display: none;
        font-family: 'MedievalSharp', cursive;
        color: #fff;
      }
      #redeemedClasses button {
        margin-top: 5px;
        padding: 5px 10px;
        border: none;
        border-radius: 4px;
        background: #27ae60;
        color: #fff;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <!-- Controls Overlay Toggle -->
    <button id="controlsToggle" onclick="toggleControls()">Controls</button>
    <!-- Admin Panel Toggle Button (visible for admins) -->
    <button id="adminToggle" onclick="toggleAdminPanel()">Admin Panel</button>
    <!-- System Button -->
    <button id="systemBtn" style="position:fixed; top:10px; left:70px; z-index:120; padding:8px 12px; background:#555; color:#fff; border:none; border-radius:4px; cursor:pointer;" onclick="toggleSystem()">System</button>
    <!-- NEW: Event Panel Toggle Button -->
    <button id="eventToggle" style="position: fixed; top:10px; left:10px; z-index:130; padding:8px 12px; background:#555; color:#fff; border:none; border-radius:4px; cursor:pointer; display:none;" onclick="toggleEventPanel()">Event Panel</button>
    <!-- Controls Overlay -->
    <div id="controlsOverlay">
      <h2>Game Controls</h2>
      <ul>
        <li><strong>Movement:</strong> Arrow Keys</li>
        <li><strong>Dodge (R):</strong> Dash</li>
        <li><strong>Fighter:</strong> F - Attack; G - Heavy Blow (Shockwave)</li>
        <li><strong>Summoner:</strong> F - Attack; G - Summon Soldiers</li>
        <li><strong>Healer:</strong> F - Heal Self; G - Heal Allies</li>
        <li><strong>Monarch:</strong> F - Attack; G - Summon Soldiers; H - Special Activation</li>
        <li><strong>Chat:</strong> Global by default; use "@username" for Private</li>
      </ul>
    </div>
  
    <!-- Global Announcement Overlay -->
    <div id="globalAnnouncement"></div>
  
    <!-- Big Notification -->
    <div id="bigNotification"></div>
  
    <div id="gameContainer">
      <canvas id="gameCanvas" width="1000" height="600"></canvas>
      <!-- Cooldown Display -->
      <div id="cooldownDisplay"></div>
      <!-- UI Overlay -->
      <div id="uiOverlay">
        <div id="infoText" style="padding: 5px; background: rgba(0,0,0,0.5); display: inline-block;">
          <span id="playerInfo">Class: </span> |
          <span id="levelInfo">Level: </span> |
          <span id="xpInfo">XP: </span> |
          <span id="hpInfo">HP: </span> |
          <span id="coinInfo">Coins: </span> |
          <span id="waveInfo"></span>
        </div>
      </div>
      <!-- Account Overlay (shown by default for new players) -->
      <div id="accountOverlay">
        <div class="mainOptions">
          <button onclick="showCreateAccount()">Create Account</button>
          <button onclick="showLogin()">Log In</button>
        </div>
        <div id="createAccountForm">
          <h3>Create Account</h3>
          <input type="text" id="createUsername" placeholder="Username" />
          <input type="password" id="createPassword" placeholder="Password" />
          <label>Choose Your Color:</label>
          <select id="createColor">
            <option value="#27ae60" selected>Green</option>
            <option value="#3498db">Blue</option>
            <option value="#e74c3c">Red</option>
            <option value="#f1c40f">Yellow</option>
            <option value="#8e44ad">Purple</option>
          </select>
          <button onclick="createAccount()">Submit</button>
          <button class="backBtn" onclick="hideCreateAccount(); showAccountOptions();">Back</button>
        </div>
        <div id="loginForm">
          <h3>Log In</h3>
          <input type="text" id="loginUsername" placeholder="Username" />
          <input type="password" id="loginPassword" placeholder="Password" />
          <button onclick="loginAccount()">Submit</button>
          <button class="backBtn" onclick="hideLogin(); showAccountOptions();">Back</button>
        </div>
      </div>
      <!-- Class Selection Bar -->
      <div id="classSelectionBar">
        <button class="classBtn" onclick="startGame('Summoner')">Summoner</button>
        <button class="classBtn" onclick="startGame('Fighter')">Fighter</button>
        <button class="classBtn" onclick="startGame('Healer')">Healer</button>
        <button class="classBtn" id="monarchBtn" onclick="attemptMonarch()">Monarch</button>
      </div>
      <!-- Monarch Unlock Overlay -->
      <div id="monarchOverlay">
        <button class="closeBtn" onclick="closeMonarchOverlay()">×</button>
        <h2>This class requires a special code, only true Leveling fans know!</h2>
        <h1>Enter Code</h1>
        <input type="text" id="monarchCode" placeholder="Enter code here" />
        <button onclick="checkMonarchCode()">Submit</button>
      </div>
      <!-- Dungeon Panel -->
      <div id="dungeonPanel">
        <h1>DUNGEON</h1>
        <ul id="dungeonList">
          <!-- Dynamically populated -->
        </ul>
        <button onclick="closeDungeonPanel()">Close</button>
      </div>
    </div>
  
    <!-- Chat Toggle Button -->
    <button id="chatToggle" onclick="toggleChat()">Chat <span id="chatBadge">0</span></button>
    <!-- Chat Container -->
    <div id="chatContainer">
      <div id="chatMessages"></div>
      <input type="text" id="chatInput" placeholder="Type a message..." />
    </div>
  
    <!-- Admin Panel -->
    <div id="adminPanel">
      <h2>Admin Panel</h2>
      <button class="closeBtn" onclick="closeAdminPanel()">×</button>
      <ul class="playerList" id="playerList">
        <!-- Dynamically populated list of players -->
      </ul>
      <!-- Global Announcement Section -->
      <div id="adminAnnouncement">
        <h3>Global Announcement</h3>
        <input type="text" id="announcementText" placeholder="Enter announcement..." />
        <input type="color" id="announcementColor" value="#ffffff" />
        <select id="announcementFont">
          <option value="Arial">Arial</option>
          <option value="Comic Sans MS">Comic Sans MS</option>
          <option value="Impact">Impact</option>
          <option value="Times New Roman">Times New Roman</option>
        </select>
        <button onclick="sendAdminAnnouncement()">Send Announcement</button>
      </div>
      <!-- NEW: Red Shutdown Button -->
      <button id="shutdownBtn" style="background:#ff0000; color:#fff; border:none; padding:10px 15px; border-radius:4px; cursor:pointer; margin-top:10px;" onclick="shutdownGame()">Shutdown</button>
    </div>
    <!-- NEW: Shutdown Overlay -->
    <div id="shutdownOverlay">
      <h1>Update Shutdown</h1>
      <p>This shutdown is most likely because of an Update or Bug Patch, please reload your page or restart the game</p>
    </div>
  
    <!-- Class Panel -->
    <div id="classPanel">
      <h2>Class Panel</h2>
      <button class="closeBtn" onclick="closeClassPanel()">×</button>
      <button onclick="setClass('The Goliath')">Set Class: The Goliath</button>
      <button onclick="setClass('Angel')">Set Class: Angel</button>
    </div>
  
    <!-- System Panel -->
    <div id="systemPanel" style="position:fixed; top:50px; left:10px; width:250px; background:rgba(0,0,0,0.9); color:#fff; padding:15px; border:2px solid:#27ae60; border-radius:8px; z-index:130; display:none;">
      <h2 style="margin-top:0; font-family:MedievalSharp;">System</h2>
      <p>Total Enemies Killed: <span id="totalKills">0</span></p>
      <p>Total Coins Collected: <span id="totalCoins">0</span></p>
      <p>Total EXP Earned: <span id="totalExp">0</span></p>
      <button style="margin-top:10px; padding:5px 10px; border:none; background:#27ae60; color:#fff; border-radius:4px; cursor:pointer;" onclick="toggleSystem()">Close</button>
    </div>

    <!-- Shop Panel -->
    <div id="shopPanel" style="display:none; position:fixed; left:calc(50% - 150px); top:calc(50% - 150px); width:300px; background:#222; border:2px solid:#27ae60; border-radius:8px; z-index:130; padding:10px;">
      <h1 style="text-align:center; font-size:32px; color:#fff;">SHOP</h1>
      <ul id="shopItemList" style="list-style:none; padding:0; color:#fff;">
        <!-- Items will be populated -->
      </ul>
      <button onclick="closeShopPanel()" style="padding:5px 10px; margin-top:10px;">Close</button>
    </div>
    
    <!-- NEW: Mobile Controls Overlay (visible only on mobile devices) -->
    <div id="mobileControls">
      <div id="dpad">
        <button id="btnUp">↑</button>
        <button id="btnLeft">←</button>
        <button id="btnDown">↓</button>
        <button id="btnRight">→</button>
      </div>
      <div id="actionButtons">
        <button id="btnAttack">F</button>
        <button id="btnSkill">G</button>
        <button id="btnDodge">R</button>
      </div>
    </div>

    <!-- NEW: Event Panel -->
    <div id="eventPanel" style="position: fixed; bottom: 50px; left: 10px; width: 300px; background: linear-gradient(135deg, #444, #222); border: 2px solid #27ae60; border-radius: 8px; z-index:150; padding:20px; display:none; resize: both; overflow: auto; color: #eaeaea;">
      <h2 style="margin:0; padding:14px; background:#27ae60; border-top-left-radius:6px; border-top-right-radius:6px; text-align:center; font-size:24px; color:#fff;">Event Panel</h2>
      <button class="closeBtn" style="position:absolute; top:5px; right:10px; background:transparent; border:none; color:#fff; font-size:26px; cursor:pointer;" onclick="toggleEventPanel()">×</button>
      <button onclick="toggleBlossomEvent()" style="width:100%; padding:10px; margin-top:10px; border:none; border-radius:4px; background:#27ae60; color:#fff; font-size:18px; cursor:pointer; transition: background 0.3s;">Blossom</button>
      <button onclick="toggleThunderEvent()" style="width:100%; padding:10px; margin-top:10px; border:none; border-radius:4px; background:#27ae60; color:#fff; font-size:18px; cursor:pointer; transition: background 0.3s;">Thunder</button>
      <button onclick="toggleMeteorEvent()" style="width:100%; padding:10px; margin-top:10px; border:none; border-radius:4px; background:#e74c3c; color:#fff; font-size:18px; cursor:pointer; transition: background 0.3s;">Meteor</button>
    </div>

    <!-- NEW: NPC Dialogue Overlay -->
    <div id="npcDialogue">
      <p id="npcMessage"></p>
      <div id="npcOptions">
        <!-- Buttons inserted dynamically -->
      </div>
    </div>
    <!-- UPDATED: Quest Panel -->
    <div id="questPanel">
      <h2>Quest Board</h2>
      <div class="questObjectives">
        <p>Kill 100 enemies: <span id="questEnemies">0/100</span></p>
        <p>Clear 5 dungeons: <span id="questDungeons">0/5</span></p>
        <p>Gain 1000 coins: <span id="questCoins">0/1000</span></p>
      </div>
      <div class="questActions">
        <button id="acceptQuest">Accept Quest</button>
        <button id="discardQuest" style="background:#ff0000;">Discard Quest</button>
      </div>
      <div class="redeemableClasses">
        <h3>Redeemable Classes</h3>
        <div id="redeemedList">
          <!-- Claimable classes will be populated here -->
        </div>
      </div>
    </div>
    <!-- NEW: Redeemed Classes List -->
    <div id="redeemedClasses">
      <h3>Redeemed Classes</h3>
      <div id="redeemedList">
        <!-- List of claimable classes -->
      </div>
    </div>
  
    <!-- Script Loading Order -->
    <script src="/socket.io/socket.io.js"></script>
    <script src="multiplayer.js"></script>
  
    <!-- Main Game Code -->
    <script>
      /********************
       * Global Setup and Variables
       ********************/
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      window.ctx = ctx;
  
      // Particle effects arrays for visual and transformation effects
      let effects = [];
      let transformationParticles = [];
      let lightningBolts = [];
  
      // Skill cooldowns (in frames/ticks)
      let heavyBlowCooldown = 0;
      let summonCooldown = 0;
      let selfHealCooldown = 0;
      let healOthersCooldown = 0;
      let monarchSpecialCooldown = 0;

      // Global stats counters
      let totalEnemiesKilled = 0;
      let totalCoinsCollected = 0;
      let totalExpEarned = 0;

      // Add a global variable for grass animation
      if (typeof grassOffset === "undefined") {
        var grassOffset = 0;
      }

      // Add a global flag for Angel Rupture effect
      let angelRuptureActive = false;

      // Move player declaration before using player elsewhere
      const player = {
        x: 500, 
        y: 300, 
        radius: 15,
        color: "#27ae60",
        speed: 3,
        class: "",
        name: "Guest",
        level: 1,
        xp: 0,
        xpThreshold: 99999,
        hp: 100,
        coins: 100,
        maxSoldiers: 2,
        weapon: null,
        dodgeTimer: 0,
        expMultiplier: 1,
        soldiers: [],
        title: "",
        transformed: false,
        transformationStart: 0,
        base_hp: 100,
        facing: "right" // Default facing direction
      };
      window.player = player;

      // NEW GLOBALS FOR SHOP & F-MOVE COOLDOWN (moved after player declaration)
      const shopItems = [
        { name: "Sword", cost: 785, damageMultiplier: 1.05 },
        { name: "Dagger", cost: 1000, damageMultiplier: 1.01, attackSpeedMultiplier: 1.10 }
      ];
      player.ownedWeapons = player.ownedWeapons || [];  // ensure ownedWeapons exists
      let fMoveCooldown = 0;
  
      let gameState = "lobby"; // "lobby" or "dungeon"
      let keys = {};
      let currentWave = 0, enemySpawnTimer = 0, enemiesSpawnedThisWave = 0, enemiesToSpawnThisWave = 0;
      let currentDungeonName = "";
      let enemies = [];
  
      // Extended dungeons list and lobby zones unchanged
      const dungeons = [
        { name: "Goblin Caves", levelReq: 1 },
        { name: "Spider Crypt", levelReq: 3 },
        { name: "Haunted Ruins", levelReq: 5 },
        { name: "Dragon’s Lair", levelReq: 10 },
        { name: "Celestial Keep", levelReq: 15 },
        { name: "Underground Catacombs", levelReq: 20 },
        { name: "Forsaken Fortress", levelReq: 25 },
        { name: "Abyssal Depths", levelReq: 30 },
        { name: "Crystal Caverns", levelReq: 35 },
        { name: "Eternal Abyss", levelReq: 40 },
        { name: "Forgotten Crypt", levelReq: 45 },
        { name: "Misty Hollow", levelReq: 50 },
        { name: "Dragon's Maw", levelReq: 55 },
        { name: "Shadow Ruins", levelReq: 60 },
        { name: "Frost Valley", levelReq: 65 },
        { name: "Lava Pits", levelReq: 70 },
        { name: "Windy Peak", levelReq: 75 },
        { name: "Mystic Forest", levelReq: 80 },
        { name: "Iron Keep", levelReq: 85 },
        { name: "Monarch's Domain", levelReq: 90 }
      ];
  
      const lobbyZones = {
        dungeonEntrance: { x: 750, y: 500, width: 200, height: 80 },
        weaponShop: { x: 50, y: 50, width: 100, height: 100 },
        cosmeticShop: { x: 50, y: 500, width: 100, height: 100 }
      };
  
      /********************
       * UI References
       ********************/
      const classSelectionBar = document.getElementById("classSelectionBar");
      const accountOverlay = document.getElementById("accountOverlay");
      const dungeonPanel = document.getElementById("dungeonPanel");
      const dungeonListEl = document.getElementById("dungeonList");
      const chatMessages = document.getElementById("chatMessages");
      const chatInput = document.getElementById("chatInput");
      const playerInfo = document.getElementById("playerInfo");
      const levelInfo = document.getElementById("levelInfo");
      const xpInfo = document.getElementById("xpInfo");
      const hpInfo = document.getElementById("hpInfo");
      const coinInfo = document.getElementById("coinInfo");
      const waveInfo = document.getElementById("waveInfo");
      const cooldownDisplay = document.getElementById("cooldownDisplay");
      const controlsOverlay = document.getElementById("controlsOverlay");
      const chatBadge = document.getElementById("chatBadge");
      const bigNotification = document.getElementById("bigNotification");
      const globalAnnouncement = document.getElementById("globalAnnouncement");
      const adminToggle = document.getElementById("adminToggle");
  
      let chatOpen = false, unreadChatCount = 0;
  
      /********************
       * Chat Filter Function
       ********************/
      function filterMessage(msg) {
        const bannedWords = ["fuck", "nigga", "idiot", "cunt", "nigger", "bitch", "shit", "runt", "stupid", "ni@@a", "f uck", "f@ck", "fu ck", "f u c k", "sex", "ass"];
        bannedWords.forEach(word => {
          let regex = new RegExp(word, "gi");
          let replacement = "#".repeat(word.length);
          msg = msg.replace(regex, replacement);
        });
        return msg;
      }
  
      /********************
       * Big On-Screen Notification
       ********************/
      function showNotification(msg) {
        bigNotification.innerText = msg;
        bigNotification.style.display = "block";
        setTimeout(() => { bigNotification.style.display = "none"; }, 3000);
      }
  
      /********************
       * Global Announcement Display Function
       ********************/
      function displayGlobalAnnouncement(msg, color, font) {
        globalAnnouncement.style.display = "block";
        globalAnnouncement.innerText = msg;
        globalAnnouncement.style.color = color;
        globalAnnouncement.style.fontFamily = font;
        globalAnnouncement.style.fontSize = "48px";
        setTimeout(() => {
          globalAnnouncement.style.display = "none";
        }, 5000);
      }
  
      /********************
       * Toggle Controls Overlay
       ********************/
      function toggleControls(){
        controlsOverlay.style.display = (controlsOverlay.style.display === "block") ? "none" : "block";
      }
  
      /********************
       * Chat Functions
       ********************/
      function appendChatMessage(sender, msg, isPrivate = false, recipient = "") {
        if(mutedPlayers[sender.name]) return;
        let div = document.createElement("div");
        let icon = document.createElement("span");
        icon.style.display = "inline-block";
        icon.style.width = "10px";
        icon.style.height = "10px";
        icon.style.background = sender.color;
        icon.style.borderRadius = "50%";
        icon.style.marginRight = "5px";
        let senderTitle = sender.title ? "[" + sender.title + "] " : "";
        let privateTag = isPrivate ? "<em>(Private)</em> " : "";
        div.innerHTML = icon.outerHTML + "<strong>" + sender.name + "</strong> " + senderTitle + privateTag + ": " + msg;
        chatMessages.appendChild(div);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
  
      function receiveChatMessage(data){
        appendChatMessage(data.sender, data.msg, data.isPrivate, data.recipient);
        if(!chatOpen) {
          unreadChatCount++;
          chatBadge.innerText = unreadChatCount;
          chatBadge.style.display = "block";
        }
      }
  
      function sendChatMessage(msg) {
        // Prevent chat if player is still a guest.
        if (window.player && window.player.name === "Guest") {
          showNotification("Please log in or create an account to chat.");
          return;
        }
        msg = filterMessage(msg);
        if (msg.startsWith("@")) {
          let parts = msg.split(" ");
          let recp = parts.shift().substring(1);
          let privateMsg = parts.join(" ");
          if (window.sendPrivateChat) { window.sendPrivateChat(recp, privateMsg); }
          appendChatMessage(player, privateMsg, true, recp);
        } else {
          let senderData = { 
            name: player.name, 
            color: player.color, 
            title: (["Administrator", "Administrator 2", "Administrator 3"].includes(player.name)) ? "Staff" : (player.title || "")
          };
          if (window.sendChat) { window.sendChat(msg); }
          appendChatMessage(senderData, msg);
        }
      }
  
      chatInput.addEventListener("keydown", (e) => {
        if(e.key === "Enter" && chatInput.value.trim() !== ""){
          sendChatMessage(chatInput.value.trim());
          chatInput.value = "";
          e.preventDefault();
        }
      });
  
      function toggleChat(){
        chatOpen = !chatOpen;
        document.getElementById("chatContainer").style.display = chatOpen ? "block" : "none";
        if(chatOpen){ unreadChatCount = 0; chatBadge.style.display = "none"; }
      }
  
      /********************
       * Account Functions
       ********************/
      function showAccountOptions() {
        document.querySelector("#accountOverlay .mainOptions").style.display = "flex";
      }
      function showCreateAccount() {
        document.querySelector("#accountOverlay .mainOptions").style.display = "none";
        document.getElementById("createAccountForm").style.display = "flex";
      }
      function hideCreateAccount() {
        document.getElementById("createAccountForm").style.display = "none";
      }
      function showLogin() {
        document.querySelector("#accountOverlay .mainOptions").style.display = "none";
        document.getElementById("loginForm").style.display = "flex";
      }
      function hideLogin() {
        document.getElementById("loginForm").style.display = "none";
      }
      function createAccount(){
        const uname = document.getElementById("createUsername").value.trim();
        const pwd = document.getElementById("createPassword").value;
        const ucolor = document.getElementById("createColor").value;
        if(uname === "" || pwd === ""){
          showNotification("Please enter a username and password.");
          return;
        }
        fetch("/create", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ username: uname, password: pwd, color: ucolor })
        })
        .then(res => {
          if(res.ok){
            player.name = uname;
            player.color = ucolor;
            if(["Administrator", "Administrator 2", "Administrator 3"].includes(uname)) {
              player.title = "Staff";
              adminToggle.style.display = "block";
            }
            accountOverlay.style.display = "none";
            classSelectionBar.style.display = "flex";
            player.xpThreshold = 99999;
            player.base_hp = 100;
            if(["Administrator", "Administrator 2", "Administrator 3"].includes(uname)) {
              document.getElementById("adminPanel").style.display = "block";
              document.getElementById("classPanel").style.display = "block";
            }
            checkAdminForEventButton();
            fetch("/logAccount", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ username: uname, password: pwd, color: ucolor })
            });
          } else {
            res.text().then(text => showNotification(text));
          }
        });
      }
      function loginAccount(){
        const uname = document.getElementById("loginUsername").value.trim();
        const pwd = document.getElementById("loginPassword").value;
        if(uname === "" || pwd === ""){
          showNotification("Please enter your username and password.");
          return;
        }
        fetch("/login", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ username: uname, password: pwd })
        })
        .then(res => {
          if(res.ok){
            res.json().then(data => {
              player.name = uname;
              player.color = data.color;
              if(["Administrator", "Administrator 2", "Administrator 3"].includes(uname)) {
                player.title = "Staff";
                adminToggle.style.display = "block";
              } else {
                player.title = data.title || "";
              }
              loadPlayerData(uname);
              accountOverlay.style.display = "none";
              classSelectionBar.style.display = "flex";
              if(["Administrator", "Administrator 2", "Administrator 3"].includes(uname)) {
                document.getElementById("adminPanel").style.display = "block";
                document.getElementById("classPanel").style.display = "block";
              }
              checkAdminForEventButton();
              fetch("/logAccount", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ username: uname, password: pwd, color: data.color })
              });
            });
          } else {
            res.text().then(text => showNotification(text));
          }
        });
      }
      function guestMode(){
        accountOverlay.style.display = "none";
        classSelectionBar.style.display = "flex";
      }
  
      function savePlayerData() {
        fetch("/save", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            username: player.name,
            data: { 
              level: player.level, 
              xp: player.xp, 
              coins: player.coins, 
              class: player.class, 
              weapon: player.weapon,
              totalEnemiesKilled,
              totalCoinsCollected,
              totalExpEarned
            }
          })
        }).then(res => res.text()).then(console.log);
      }
      function loadPlayerData(username) {
        fetch("/load/" + username)
        .then(res => {
          if(res.ok) return res.json();
          else throw new Error("User not found");
        })
        .then(data => {
          player.level = data.level;
          player.xp = data.xp;
          player.coins = data.coins;
          player.class = data.class;
          player.weapon = data.weapon;
          totalEnemiesKilled = data.totalEnemiesKilled || 0;
          totalCoinsCollected = data.totalCoinsCollected || 0;
          totalExpEarned = data.totalExpEarned || 0;
          player.base_hp = 100 + (player.level - 1) * 10;
          player.hp = player.transformed ? player.base_hp + 1000 : player.base_hp;
          updateUI();
        })
        .catch(err => showNotification(err.message));
      }
  
      /********************
       * Class Selection and Monarch Unlock
       ********************/
      function startGame(chosenClass){
        player.class = chosenClass;
        if(chosenClass === "Monarch"){
          player.maxSoldiers = 6; // modified: Monarch now can summon up to 6 soldiers
        }
        if(chosenClass === "Angel"){
          player.angel = true;
        }
        player.xpThreshold = 99999;
        player.base_hp = 100 + (player.level - 1) * 10;
        player.hp = player.base_hp;
        classSelectionBar.style.display = "none";
        gameState = "lobby";
        updateUI();
      }
      function attemptMonarch(){
        document.getElementById("monarchOverlay").style.display = "block";
      }
      function closeMonarchOverlay(){
        document.getElementById("monarchOverlay").style.display = "none";
      }
      function checkMonarchCode(){
        const code = document.getElementById("monarchCode").value;
        if(code === "IGRIS"){
          closeMonarchOverlay();
          startGame("Monarch");
        } else {
          showNotification("Incorrect Code!");
        }
      }
  
      /********************
       * Movement and Dodge
       ********************/
      // Store dash trail positions for dodge effect
      let dodgeTrail = [];

      function movePlayer(){
        if(gameState === "lobby" || gameState === "dungeon"){
          if(keys["ArrowUp"]) player.y -= player.speed;
          if(keys["ArrowDown"]) player.y += player.speed;
          if(keys["ArrowLeft"]) { player.x -= player.speed; player.facing = "left"; }
          if(keys["ArrowRight"]) { player.x += player.speed; player.facing = "right"; }
          player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
          player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));
        }
      }
      function dodge(){
        let dash = 50;
        // Store initial position for trail
        let startX = player.x, startY = player.y;
        if(keys["ArrowUp"]) player.y -= dash;
        if(keys["ArrowDown"]) player.y += dash;
        if(keys["ArrowLeft"]) player.x -= dash;
        if(keys["ArrowRight"]) player.x += dash;
        player.dodgeTimer = 30;
        createEffect(player.x, player.y, "#fff");
        broadcastEffect(player.x, player.y, "#fff");
        // NEW: Add trail segment for dodge
        dodgeTrail.push({
          x1: startX, y1: startY,
          x2: player.x, y2: player.y,
          alpha: 1.0, life: 0
        });
      }

      // NEW: Draw dodge trail in main draw loop
      function drawDodgeTrail() {
        for (let i = 0; i < dodgeTrail.length; i++) {
          let seg = dodgeTrail[i];
          let grad = ctx.createLinearGradient(seg.x1, seg.y1, seg.x2, seg.y2);
          grad.addColorStop(0, "rgba(255,255,255," + (seg.alpha * 0.5) + ")");
          grad.addColorStop(1, "rgba(39,174,96," + (seg.alpha * 0.2) + ")");
          ctx.save();
          ctx.strokeStyle = grad;
          ctx.lineWidth = 12 * seg.alpha;
          ctx.globalAlpha = seg.alpha;
          ctx.beginPath();
          ctx.moveTo(seg.x1, seg.y1);
          ctx.lineTo(seg.x2, seg.y2);
          ctx.stroke();
          ctx.restore();
        }
      }
      function updateDodgeTrail() {
        for (let i = dodgeTrail.length - 1; i >= 0; i--) {
          dodgeTrail[i].life++;
          dodgeTrail[i].alpha -= 0.04;
          if (dodgeTrail[i].alpha <= 0) dodgeTrail.splice(i, 1);
        }
      }
  
      /********************
       * Enemy Classes and Dungeon Waves
       ********************/
      // Helper: Get dungeon index for scaling
      function getDungeonIndex() {
        return dungeons.findIndex(d => d.name === currentDungeonName);
      }

      // Helper: Get enemy level based on dungeon and wave
      function getEnemyLevel(type, wave) {
        let dungeonIdx = getDungeonIndex();
        let base = 1 + dungeonIdx * 2 + (wave ? wave : currentWave);
        if (type === "Boss") base += 10;
        return base;
      }

      // Enhanced Enemy class with level and boss abilities
      class Enemy {
        constructor(x, y, type = "Warrior", wave = null) {
          this.x = x; this.y = y; this.radius = 15;
          this.type = type; this.lastAttackTime = Date.now();
          this.level = getEnemyLevel(type, wave);
          this.setAttributes();
          this.maxHp = this.hp;
          // Boss ability timers
          if (this.type === "Boss") {
            this.specialTimer = 0;
            this.rangedAttackTimer = 0;
            this.shockwaveTimer = 0;
            this.projectiles = [];
          }
        }
        setAttributes(){
          let dungeonIdx = getDungeonIndex();
          let wave = currentWave;
          let scale = 1 + dungeonIdx * 0.5 + (wave-1) * 0.15;
          // Bosses scale much more, but reduce HP multiplier for faster fights
          let bossScale = 0.8 + dungeonIdx * 0.7 + (wave-1) * 0.18; // Lowered base and per-dungeon scaling
          switch(this.type){
            case "Warrior":
              this.color = "#e74c3c"; this.radius = 15; this.speed = 2;
              this.hp = Math.floor(40 * scale);
              this.damage = Math.floor(20 * scale);
              this.attackInterval = 2000; this.name = "Warrior";
              break;
            case "Mage":
              this.color = "#9b59b6"; this.radius = 15; this.speed = 1.5;
              this.hp = Math.floor(35 * scale);
              this.damage = Math.floor(16 * scale);
              this.attackInterval = 3000; this.name = "Mage";
              break;
            case "Tank":
              this.color = "#34495e"; this.radius = 20; this.speed = 1;
              this.hp = Math.floor(80 * scale);
              this.damage = Math.floor(12 * scale);
              this.attackInterval = 1500; this.name = "Tank";
              break;
            case "Boss":
              this.color = "#c0392b"; this.radius = 38; this.speed = 1.7;
              this.hp = Math.floor(400 * bossScale); // Lowered base HP from 800 to 400
              this.damage = Math.floor(60 * bossScale);
              this.attackInterval = 1200; this.name = "Boss";
              break;
            case "Assassin":
              this.color = "#2ecc71"; this.radius = 12; this.speed = 3.2;
              this.hp = Math.floor(30 * scale);
              this.damage = Math.floor(24 * scale);
              this.attackInterval = 1000; this.name = "Assassin";
              break;
            case "Sorcerer":
              this.color = "#8e44ad"; this.radius = 14; this.speed = 2.2;
              this.hp = Math.floor(45 * scale);
              this.damage = Math.floor(20 * scale);
              this.attackInterval = 2500; this.name = "Sorcerer";
              break;
            default:
              this.color = "#e74c3c"; this.radius = 15; this.speed = 2;
              this.hp = Math.floor(40 * scale);
              this.damage = Math.floor(20 * scale);
              this.attackInterval = 2000; this.name = "Warrior";
          }
          // Extra hard for Monarch's Domain
          if(currentDungeonName === "Monarch's Domain") {
            this.hp = Math.floor(this.hp * 1.7);
            this.damage = Math.floor(this.damage * 1.5);
          }
          this.maxHp = this.hp;
        }
        move(){
          let dx = player.x - this.x, dy = player.y - this.y, dist = Math.hypot(dx, dy);
          if(dist > 0){
            this.x += (dx/dist) * this.speed;
            this.y += (dy/dist) * this.speed;
          }
        }
        attackPlayer(){
          let d = Math.hypot(player.x - this.x, player.y - this.y);
          let now = Date.now();
          if(d < player.radius + this.radius + 5 && now - this.lastAttackTime >= this.attackInterval && player.dodgeTimer === 0){
            player.hp -= this.damage;
            this.lastAttackTime = now;
            if(player.hp <= 0){
              if(window.socket) window.socket.disconnect();
              showNotification("Game Over!");
              document.location.reload();
            }
          }
        }
        // Boss special abilities
        bossAbilities(){
          let now = Date.now();
          // Ranged fireball every 2.5s
          if(now - (this.rangedAttackTimer||0) > 2500){
            this.rangedAttackTimer = now;
            let angle = Math.atan2(player.y - this.y, player.x - this.x);
            this.projectiles.push({
              x: this.x, y: this.y,
              dx: Math.cos(angle)*7, dy: Math.sin(angle)*7,
              radius: 10, color: "#ff9800", alive: true
            });
          }
          // Shockwave every 4s
          if(now - (this.shockwaveTimer||0) > 4000){
            this.shockwaveTimer = now;
            createEffect(this.x, this.y, "#ff2222");
            // All enemies get a temporary speed boost
            this.speed += 1.5;
            setTimeout(()=>{ this.speed -= 1.5; }, 1200);
          }
          // Animate projectiles
          this.projectiles.forEach(p => {
            p.x += p.dx; p.y += p.dy;
            // Collision with player
            if(p.alive && Math.hypot(player.x-p.x, player.y-p.y) < player.radius + p.radius){
              player.hp -= Math.floor(this.damage * 0.7);
              p.alive = false;
              createEffect(p.x, p.y, "#ff9800");
            }
            // Out of bounds
            if(p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) p.alive = false;
          });
          this.projectiles = this.projectiles.filter(p=>p.alive);
        }
        draw(){
          ctx.beginPath(); ctx.fillStyle = this.color;
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
          // HP bar
          let barWidth = this.radius * 2, barHeight = 5, hpRatio = this.hp / this.maxHp;
          ctx.fillStyle = "red";
          ctx.fillRect(this.x - this.radius, this.y - this.radius - 15, barWidth, barHeight);
          ctx.fillStyle = "green";
          ctx.fillRect(this.x - this.radius, this.y - this.radius - 15, barWidth * hpRatio, barHeight);
          // Enemy name and level
          ctx.fillStyle = "#fff"; ctx.font = "10px MedievalSharp";
          let txt = this.name + " (Lv." + this.level + ")";
          let txtWidth = ctx.measureText(txt).width;
          ctx.fillText(txt, this.x - txtWidth/2, this.y - this.radius - 22);
          // Boss: draw projectiles and special effects
          if(this.type === "Boss"){
            // Animate projectiles
            this.projectiles.forEach(p => {
              ctx.save();
              ctx.globalAlpha = 0.85;
              ctx.beginPath();
              ctx.arc(p.x, p.y, p.radius, 0, Math.PI*2);
              ctx.fillStyle = p.color;
              ctx.shadowColor = "#ff9800";
              ctx.shadowBlur = 12;
              ctx.fill();
              ctx.restore();
            });
            // Aura
            ctx.save();
            ctx.globalAlpha = 0.3;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius+18+Math.sin(Date.now()/200)*4, 0, Math.PI*2);
            ctx.strokeStyle = "#ff2222";
            ctx.lineWidth = 6;
            ctx.shadowColor = "#ff2222";
            ctx.shadowBlur = 18;
            ctx.stroke();
            ctx.restore();
          }
        }
      }

      // --- Enemy Spawning Logic ---
      function spawnDungeonEnemy(){
        let rand = Math.random(), type = "Warrior";
        // Only 1 boss at wave 10
        if(currentWave === 10){
          type = "Boss";
        } else if(["Eternal Abyss", "Forgotten Crypt", "Misty Hollow", "Dragon's Maw"].includes(currentDungeonName)){
          if(rand < 0.25) { type = "Assassin"; }
          else if(rand < 0.5){ type = "Sorcerer"; }
          else if(rand < 0.7){ type = "Mage"; }
          else if(rand < 0.85){ type = "Tank"; }
          else { type = "Warrior"; }
        } else {
          if(currentWave < 10){
            if(rand < 0.2) type = "Mage";
            else if(rand < 0.4) type = "Tank";
            else type = "Warrior";
          }
        }
        // Only spawn boss if not already present
        if(type === "Boss" && enemies.some(e=>e.type==="Boss")) return;
        let x = Math.random() * canvas.width, y = -20;
        enemies.push(new Enemy(x, y, type, currentWave));
        enemiesSpawnedThisWave++;
      }

      // --- Dungeon Wave Handler ---
      function dungeonWaveHandler(){
        // Only 1 boss at wave 10
        if(currentWave === 10 && enemies.filter(e=>e.type==="Boss").length > 1){
          // Remove extra bosses if any
          enemies = enemies.filter((e,i,arr)=>e.type!=="Boss" || arr.findIndex(x=>x.type==="Boss")===i);
        }
        if(enemiesSpawnedThisWave === enemiesToSpawnThisWave && enemies.length === 0){
          // ...existing code...
          if (player.quest && !player.quest.completed) {
            player.quest.progress.dungeons = (player.quest.progress.dungeons || 0) + 1;
            showNotification("Dungeon Cleared! (" + player.quest.progress.dungeons + "/5)");
          }
          if(currentDungeonName === "Monarch's Domain"){
            if(currentWave < 20){
              currentWave++;
              showNotification("Wave " + currentWave + " starting!");
              player.coins += 20;
              enemiesSpawnedThisWave = 0; enemiesToSpawnThisWave = (currentWave === 10 ? 1 : 3);
            } else {
              showNotification("Dungeon Completed!");
              gameState = "lobby";
            }
          } else {
            if(currentWave < 10){
              currentWave++;
              showNotification("Wave " + currentWave + " starting!");
              player.coins += 20;
              enemiesSpawnedThisWave = 0; enemiesToSpawnThisWave = (currentWave === 10 ? 1 : 3);
            } else {
              showNotification("Dungeon Completed!");
              gameState = "lobby";
            }
          }
        }
      }

      // --- Spawn correct number of enemies per wave ---
      function spawnDungeonWaveEnemies(){
        // Only 1 boss at wave 10
        if(currentWave === 10){
          if(enemiesSpawnedThisWave < 1) spawnDungeonEnemy();
          enemySpawnTimer = 0;
          return;
        }
        if(enemiesSpawnedThisWave < enemiesToSpawnThisWave){
          spawnDungeonEnemy();
          enemySpawnTimer = 0;
        }
      }

      /********************
       * Attack Functions, Special Effects, and Cooldowns
       ********************/
      function playerAttack(){
        enemies.forEach((enemy, idx) => {
          let d = Math.hypot(player.x - enemy.x, player.y - enemy.y);
          if(d < player.radius + enemy.radius + 20){
            let baseDamage = 20;
            if(player.class === "Fighter") baseDamage += 30;
            if(player.weapon) baseDamage += player.weapon.damage;
            enemy.hp -= baseDamage;
            createEffect(enemy.x, enemy.y, "#fff");
            broadcastEffect(enemy.x, enemy.y, "#fff");
            if(enemy.hp <= 0){
              totalEnemiesKilled++;
              totalExpEarned += 20;
              player.coins += 10;
              totalCoinsCollected += 10;
              addXP(20);
              enemies.splice(idx, 1);
            }
          }
        });
      }
  
      function heavyBlow(){
        if(heavyBlowCooldown > 0) return;
        enemies.forEach((enemy, idx) => {
           let d = Math.hypot(player.x - enemy.x, player.y - enemy.y);
          if(d < player.radius + enemy.radius + 40){
            let damage = 70;
            if(player.weapon) damage += player.weapon.damage;
            enemy.hp -= damage;
            createEffect(enemy.x, enemy.y, "#f39c12");
            broadcastEffect(enemy.x, enemy.y, "#f39c12");
            if(enemy.hp <= 0){
              totalEnemiesKilled++;
              totalExpEarned += 20;
              player.coins += 10;
              totalCoinsCollected += 10;
              addXP(20);
              enemies.splice(idx, 1);
            }
          }
        });
        heavyBlowCooldown = 180;
      }
  
      function selfHeal(){
        if(selfHealCooldown > 0) return;
        let healAmount = 30;
        player.hp = Math.min(player.base_hp + (player.transformed ? 1000 : 0), player.hp + healAmount);
        createEffect(player.x, player.y, "#27ae60");
        broadcastEffect(player.x, player.y, "#27ae60");
        selfHealCooldown = 150;
        showNotification("Self Healed for " + healAmount + " HP!");
      }
  
      function healOthers(){
        if(healOthersCooldown > 0) return;
        player.soldiers.forEach(soldier => {
          soldier.healed = true;
          createEffect(soldier.x, soldier.y, "#27ae60");
          broadcastEffect(soldier.x, soldier.y, "#27ae60");
        });
        healOthersCooldown = 150;
        showNotification("All allies healed!");
      }
  
      function activateMonarchSpecial(){
        if(monarchSpecialCooldown > 0) return;
        player.soldiers.forEach(soldier => {
          soldier.specialTimer = 200;
          soldier.attackMultiplier = 2;
          soldier.effect = "superglow";
          createEffect(soldier.x, soldier.y, "#ff0");
          broadcastEffect(soldier.x, soldier.y, "#ff0");
        });
        monarchSpecialCooldown = 240;
        showNotification("Monarch Special Activated!");
      }
  
      /********************
       * The Goliath Class Abilities
       ********************/
      function activateGoliathFMove() {
        if(player.class !== "The Goliath") return;
        enemies.forEach((enemy, idx) => {
          let d = Math.hypot(player.x - enemy.x, player.y - enemy.y);
          if(d < player.radius + enemy.radius + 60){
            let damage = 50;
            enemy.hp -= damage;
            for(let i = 0; i < 3; i++){
              setTimeout(() => {
                createEffect(enemy.x, enemy.y, "gold");
                broadcastEffect(enemy.x, enemy.y, "gold");
              }, i * 50);
            }
            if(enemy.hp <= 0){
              totalEnemiesKilled++;
              totalExpEarned += 20;
              player.coins += 10;
              totalCoinsCollected += 10;
              addXP(20);
              enemies.splice(idx, 1);
            }
          }
        });
      }
  
      function activateGoliathGMove() {
        if(player.class !== "The Goliath") return;
        enemies.forEach((enemy, idx) => {
          let d = Math.hypot(player.x - enemy.x, player.y - enemy.y);
          if(d < player.radius + enemy.radius + 80){
            let damage = 100;
            enemy.hp -= damage;
            createEffect(enemy.x, enemy.y, "gold");
            broadcastEffect(enemy.x, enemy.y, "gold");
            if(enemy.hp <= 0){
              totalEnemiesKilled++;
              totalExpEarned += 20;
              player.coins += 10;
              totalCoinsCollected += 10;
              addXP(20);
              enemies.splice(idx, 1);
            }
          }
        });
        ctx.fillStyle = "rgba(255,215,0,0.5)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
  
      function activateGoliathHMove() {
        if(player.class !== "The Goliath") return;
        broadcastGlobalNotification("Call me your Goliath!", 5000);
        for(let i = 0; i < 50; i++){
          setTimeout(() => {
            let angle = Math.random() * 2 * Math.PI;
            let dist = Math.random() * 300;
            let ex = player.x + Math.cos(angle) * dist;
            let ey = player.y + Math.sin(angle) * dist;
            createEffect(ex, ey, "gold");
            broadcastEffect(ex, ey, "gold");
          }, i * 30);
        }
        enemies.forEach(enemy => { enemy.hp = 0; });
        ctx.fillStyle = "#fff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        setTimeout(() => { ctx.clearRect(0, 0, canvas.width, canvas.height); }, 100);
      }
  
      function activateGoliathTransformation() {
        if(player.class !== "The Goliath") return;
        if(!player.transformed) {
          player.transformed = true;
          player.transformationStart = Date.now();
          player.hp += 1000;
          showNotification("Goliath Transformation Activated! +1000 HP bonus");
          ctx.fillStyle = "rgba(255,223,0,0.3)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        } else {
          player.transformed = false;
          player.hp = player.base_hp;
          showNotification("Goliath Transformation Deactivated!");
          transformationParticles = [];
          lightningBolts = [];
        }
      }

      /********************
       * Angel Class Ability
       ********************/
      function activateTheRupture(){
        if(window.socket && window.socket.connected){
            window.socket.emit("angelRupture");
        }
        doAngelRuptureEffect();
        enemies.forEach(enemy => enemy.hp = 0);
        gameState = "lobby";
        showNotification("The Rupture activated! Dungeon Cleared!");
      }

      function doAngelRuptureEffect(){
        angelRuptureActive = true;
        setTimeout(() => { angelRuptureActive = false; }, 2000);
      }
  
      /********************
       * Global Notification for All Players
       ********************/
      function showGlobalNotification(msg, duration){
        bigNotification.innerText = msg;
        bigNotification.style.display = "block";
        setTimeout(() => { bigNotification.style.display = "none"; }, duration);
      }
  
      function broadcastGlobalNotification(msg, duration){
        if(window.socket && window.socket.connected){
          window.socket.emit("globalNotification", { msg, duration });
        }
      }
  
      /********************
       * XP and Leveling
       ********************/
      function addXP(amount){
        amount *= player.expMultiplier;
        player.xp += amount;
        if(player.xpThreshold === 99999) {
          player.xpThreshold = Math.floor(player.level * 100 * 1.1);
        }
        while(player.xp >= player.xpThreshold && player.level < 99){
          player.xp -= player.xpThreshold;
          player.level++;
          player.base_hp = 100 + (player.level - 1) * 10;
          player.hp = player.transformed ? player.base_hp + 1000 : player.base_hp;
          player.xpThreshold = Math.floor(player.level * 100 * 1.1);
          if(player.level >= 99) showNotification("Congratulations! You've reached level 99!");
        }
      }
  
      /********************
       * Drawing Functions
       ********************/
      function drawPlayer(){
        if(player.class === "Angel"){
          let drawY = player.y + Math.sin(Date.now()/500)*5;
          ctx.beginPath();
          ctx.fillStyle = "#fff";
          ctx.arc(player.x, drawY, player.radius, 0, Math.PI*2);
          ctx.fill();
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(player.x - player.radius, drawY);
          ctx.quadraticCurveTo(player.x - player.radius - 20, drawY - 20 + Math.sin(Date.now()/300)*5, player.x - player.radius, drawY - 10);
          ctx.moveTo(player.x + player.radius, drawY);
          ctx.quadraticCurveTo(player.x + player.radius + 20, drawY - 20 + Math.sin(Date.now()/300)*5, player.x + player.radius, drawY - 10);
          ctx.stroke();
          ctx.fillStyle = "#fff";
          ctx.font = "12px MedievalSharp";
          let classStr = "Class: Angel";
          let classWidth = ctx.measureText(classStr).width;
          ctx.fillText(classStr, player.x - classWidth/2, drawY + player.radius + 15);
          return;
        }
        if(player.transformed){
          ctx.save();
          ctx.shadowBlur = 40;
          ctx.shadowColor = "gold";
          ctx.beginPath();
          ctx.arc(player.x, player.y, player.radius * 1.8, 0, Math.PI * 2);
          ctx.fillStyle = "gold";
          ctx.fill();
          drawTransformationEffects();
          ctx.restore();
        }
        ctx.beginPath();
        ctx.fillStyle = player.color;
        let radius = (player.class === "The Goliath" && player.transformed) ? player.radius * 1.8 : player.radius;
        ctx.arc(player.x, player.y, radius, 0, Math.PI * 2);
        ctx.fill();
        if(["Administrator", "Administrator 2", "Administrator 3"].includes(player.name)){
          ctx.fillStyle = "#ff0000";
          ctx.font = "bold 12px MedievalSharp";
          let staffText = "Staff";
          let staffWidth = ctx.measureText(staffText).width;
          ctx.fillText(staffText, player.x - staffWidth/2, player.y - 30);
        } else if(player.title){
          ctx.fillStyle = "#ff0000";
          ctx.font = "bold 12px MedievalSharp";
          let tWidth = ctx.measureText(player.title).width;
          ctx.fillText(player.title, player.x - tWidth/2, player.y - 40);
        }
        ctx.fillStyle = "#ffffff";
        ctx.font = "12px MedievalSharp";
        let displayText = player.name + " (LVL " + player.level + ")";
        let dtWidth = ctx.measureText(displayText).width;
        ctx.fillText(displayText, player.x - dtWidth/2, player.y - radius - 5);
        if(player.class){
          let classStr = "Class: " + player.class;
          let classWidth = ctx.measureText(classStr).width;
          ctx.fillText(classStr, player.x - classWidth/2, player.y - radius + 10);
        }
        // NEW: Draw improved weapon model if equipped
        if(player.weapon){
          drawWeapon(player.weapon, player.x, player.y, radius);
        }
      }

      // UPDATED: New drawWeapon function with enhanced weapon models
      function drawWeapon(weapon, playerX, playerY, radius) {
        let time = Date.now() / 1000;
        let swingAngle = Math.sin(time * (weapon.name === "Dagger" ? 7 : 5)) * 0.05;
        ctx.save();
        // Translate so the weapon is held outside the player's circle.
        if (player.facing === "left") {
          ctx.translate(playerX - radius - 10, playerY);
          ctx.scale(-1, 1);
        } else {
          ctx.translate(playerX + radius + 10, playerY);
        }
        ctx.rotate(swingAngle);
        if (weapon.name === "Sword") {
          // UPDATED SWORD: Sharper, slightly smaller, and more realistic.
          // Blade: Tapered polygon from hilt to sharp tip.
          ctx.beginPath();
          ctx.moveTo(0, -28);      // Tip of the blade
          ctx.lineTo(2, -26);      // Right edge
          ctx.lineTo(1, 0);        // Bottom right (near hilt)
          ctx.lineTo(-1, 0);       // Bottom left
          ctx.lineTo(-2, -26);     // Left edge
          ctx.closePath();
          let bladeGrad = ctx.createLinearGradient(0, -28, 0, 0);
          bladeGrad.addColorStop(0, "#e0e0e0"); // Lighter at the tip
          bladeGrad.addColorStop(1, "#a0a0a0"); // Darker near hilt
          ctx.fillStyle = bladeGrad;
          ctx.fill();
          // Guard: Slim and minimal.
          ctx.beginPath();
          ctx.moveTo(-3, 1);
          ctx.lineTo(3, 1);
          ctx.lineTo(2, 3);
          ctx.lineTo(-2, 3);
          ctx.closePath();
          ctx.fillStyle = "#8b4513";
          ctx.fill();
          // Hilt: Short and simple.
          ctx.fillStyle = "#a0522d";
          ctx.fillRect(-1.5, 3, 3, 10);
          // Pommel: Small, circular, with a metallic tone.
          ctx.fillStyle = "#d4af37";
          ctx.beginPath();
          ctx.arc(0, 14, 2, 0, Math.PI * 2);
          ctx.fill();
        } else if (weapon.name === "Dagger") {
          // Reduced dagger model dimensions.
          ctx.fillStyle = "#d3d3d3";
          ctx.beginPath();
          ctx.moveTo(0, -18);         // tip reduced from -25 to -18
          ctx.lineTo(2, -7);
          ctx.lineTo(1.5, 0);
          ctx.lineTo(-1.5, 0);
          ctx.lineTo(-2, -7);
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = "#555";
          ctx.fillRect(-1, 0, 2, 4);
          ctx.fillStyle = "#ffd700";
          ctx.beginPath();
          ctx.arc(0, 1.5, 1, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }
  
      function drawTransformationEffects(){
        transformationParticles.forEach(particle => {
          ctx.save();
          ctx.globalAlpha = particle.alpha;
          ctx.fillStyle = "orange";
          ctx.beginPath();
          ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });
        lightningBolts.forEach(bolt => {
          ctx.save();
          ctx.globalAlpha = bolt.alpha;
          ctx.strokeStyle = "red";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(bolt.x, bolt.y);
          ctx.lineTo(bolt.x + bolt.dx, bolt.y + bolt.dy);
          ctx.stroke();
          ctx.restore();
        });
      }
  
      function updateTransformationEffects() {
        if(!player.transformed) return;
        let now = Date.now();
        let angle = ((now - player.transformationStart) / 50) % (Math.PI * 2);
        let dist = 30;
        transformationParticles.push({
          x: player.x + Math.cos(angle) * dist,
          y: player.y + Math.sin(angle) * dist,
          radius: 4,
          alpha: 1
        });
        transformationParticles = transformationParticles.map(p => {
          p.radius *= 1.01;
          p.alpha -= 0.02;
          return p;
        }).filter(p => p.alpha > 0);
  
        if(!player.lastLightning || now - player.lastLightning > 2000) {
          player.lastLightning = now;
          lightningBolts.push({
            x: player.x,
            y: player.y,
            dx: (Math.random() - 0.5) * 300,
            dy: (Math.random() - 0.5) * 300,
            alpha: 1
          });
        }
        lightningBolts = lightningBolts.map(bolt => {
          bolt.alpha -= 0.02;
          return bolt;
        }).filter(bolt => bolt.alpha > 0);
      }
  
      function updateSoldiers(){
        const formationRadius = 30;
        player.soldiers.forEach((soldier, i) => {
          let angle = (i / player.soldiers.length) * 2 * Math.PI;
          let targetX = player.x + formationRadius * Math.cos(angle);
          let targetY = player.y + formationRadius * Math.sin(angle);
          let targetEnemy = null, minD = Infinity;
          enemies.forEach(enemy => {
            let d = Math.hypot(soldier.x - enemy.x, soldier.y - enemy.y);
            if(d < minD){ minD = d; targetEnemy = enemy; }
          });
          if(gameState === "dungeon" && targetEnemy && minD < 200){
            let dx = targetEnemy.x - soldier.x, dy = targetEnemy.y - soldier.y;
            let dist = Math.hypot(dx, dy);
            if(dist > 0){
              soldier.x += (dx/dist) * soldier.speed;
              soldier.y += (dy/dist) * soldier.speed;
            }
            if(dist < soldier.radius + targetEnemy.radius + 5 && soldier.attackCooldown === 0){
              let damage = 15 * soldier.attackMultiplier;
              targetEnemy.hp -= damage;
              soldier.attackCooldown = 30;
              if(targetEnemy.hp <= 0){
                totalEnemiesKilled++;
                totalExpEarned += 20;
                player.coins += 10;
                totalCoinsCollected += 10;
                addXP(20);
                enemies = enemies.filter(e => e !== targetEnemy);
              }
            }
          } else {
            let dx = targetX - soldier.x, dy = targetY - soldier.y;
            let dist = Math.hypot(dx, dy);
            if(dist > 5){
              soldier.x += (dx/dist) * soldier.speed;
              soldier.y += (dy/dist) * soldier.speed;
            }
          }
          if(soldier.attackCooldown > 0) soldier.attackCooldown--;
          if(soldier.specialTimer > 0){
            soldier.specialTimer--;
            if(soldier.specialTimer === 0){
              soldier.attackMultiplier = 1;
              soldier.effect = (player.class === "Monarch") ? "glow" : soldier.effect;
            }
          }
        });
      }
  
      function drawSoldiers(){
        if(gameState !== "dungeon") return;
        player.soldiers.forEach(soldier => {
          ctx.beginPath();
          ctx.fillStyle = soldier.color;
          ctx.arc(soldier.x, soldier.y, soldier.radius, 0, Math.PI * 2);
          ctx.fill();
          if(soldier.effect === "glow" || soldier.effect === "superglow"){
            ctx.strokeStyle = (soldier.effect === "superglow") ? "#ff0" : "#fff";
            ctx.lineWidth = 2;
            ctx.stroke();
          }
        });
      }
  
      function drawEnemies(){
        enemies.forEach(enemy => enemy.draw());
      }
  
      function updateUI(){
        playerInfo.innerText = "Class: " + player.class;
        levelInfo.innerText = "Level: " + player.level;
        xpInfo.innerText = "XP: " + player.xp + "/" + player.xpThreshold;
        hpInfo.innerText = "HP: " + player.hp;
        coinInfo.innerText = "Coins: " + player.coins;
        waveInfo.innerText = (gameState === "dungeon") ? ("Wave: " + currentWave + "/10") : "";
      }
  
      /********************
       * Cooldown Display Update
       ********************/
      function updateCooldownDisplay(){
        let lines = [];
        if(player.class === "The Goliath"){
          lines.push("Goliath F: Ready");
          lines.push("Goliath G: Ready");
          lines.push("Goliath H: Ready");
        }
        if(player.class === "Fighter"){
          lines.push("Heavy Blow (G): " + (heavyBlowCooldown > 0 ? heavyBlowCooldown : "Ready"));
        }
        if(player.class === "Summoner" || player.class === "Monarch"){
          lines.push("Summon (G): " + (summonCooldown > 0 ? summonCooldown : "Ready"));
        }
        if(player.class === "Healer"){
          lines.push("Heal Self (F): " + (selfHealCooldown > 0 ? selfHealCooldown : "Ready"));
          lines.push("Heal Allies (G): " + (healOthersCooldown > 0 ? healOthersCooldown : "Ready"));
        }
        if(player.class === "Monarch"){
          lines.push("Special (H): " + (monarchSpecialCooldown > 0 ? monarchSpecialCooldown : "Ready"));
        }
        lines.push("Dodge (R): " + (player.dodgeTimer > 0 ? player.dodgeTimer : "Ready"));
        if(player.class === "The Goliath") {
          lines.push("Transform (T)");
        }
        if(player.class === "Angel") {
          lines.push("The Rupture (U): Ready");
        }
        cooldownDisplay.innerHTML = lines.join("<br>");
      }
  
      /********************
       * Revamped Lobby and Dungeon Functions
       ********************/
      function drawLobby(){
        // Create a darker, refined gradient for a realistic stone background.
        let stoneGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        stoneGradient.addColorStop(0, "#555");
        stoneGradient.addColorStop(0.5, "#444");
        stoneGradient.addColorStop(1, "#333");
        ctx.fillStyle = stoneGradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw animated grass instead of static green rectangle.
        drawAnimatedGrass();
        
        // FIXED: Ensure trees are drawn
        let treePositions = [
          { x: canvas.width * 0.35, y: canvas.height * 0.5 },
          { x: canvas.width * 0.5, y: canvas.height * 0.45 },
          { x: canvas.width * 0.65, y: canvas.height * 0.5 }
        ];
        treePositions.forEach(pos => {
          drawDetailedTree(pos.x, pos.y);
        });
        
        // Draw animated dungeon portal.
        drawAnimatedPortal(lobbyZones.dungeonEntrance);
        
        // Draw shop keeper model.
        drawShopKeeper(100, canvas.height - 80);
      }

      // New function: Draw animated grass at the bottom.
      function drawAnimatedGrass(){
        for(let i = 0; i < canvas.width; i += 10){
          let height = 10 + Math.sin((i + grassOffset) / 10) * 5;
          // Set grass color to purple.
          ctx.fillStyle = "#800080";
          ctx.fillRect(i, canvas.height - height, 8, height);
        }
      }

      // Update drawDetailedTree to include a slight sway animation.
      function drawDetailedTree(x, y) {
        let sway = Math.sin(Date.now()/1000 + x)*3;
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(x - 5, y, 10, 40);
        ctx.fillStyle = "#228B22";
        ctx.beginPath();
        ctx.arc(x + sway, y - 10, 20, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#2E8B57";
        ctx.beginPath();
        ctx.arc(x + sway, y - 30, 25, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#006400";
        ctx.beginPath();
        ctx.arc(x + sway, y - 50, 20, 0, Math.PI * 2);
        ctx.fill();
      }

      // UPDATED: drawAnimatedPortal – now with shining, glowing, and animated effects
      function drawAnimatedPortal(zone) {
          let time = Date.now() / 500;
          let baseRadius = 54 + Math.sin(time) * 6; // slightly bigger
          let centerX = zone.x + zone.width / 2;
          let centerY = zone.y + zone.height / 2;
      
          ctx.save();
      
          // Draw a glowing aura (multiple blurred circles)
          for (let i = 4; i >= 1; i--) {
              ctx.beginPath();
              ctx.arc(centerX, centerY, baseRadius + i * 10, 0, Math.PI * 2);
              ctx.globalAlpha = 0.08 * i;
              ctx.fillStyle = `hsl(${280 + Math.sin(time + i) * 20}, 100%, 70%)`;
              ctx.shadowColor = `hsl(${280 + Math.sin(time + i) * 20}, 100%, 70%)`;
              ctx.shadowBlur = 30 + i * 10;
              ctx.fill();
          }
          ctx.globalAlpha = 1;
          ctx.shadowBlur = 0;
      
          // Draw animated sparkles around the portal
          for (let i = 0; i < 12; i++) {
              let angle = i * (Math.PI * 2 / 12) + time * 0.7;
              let sparkleRadius = baseRadius + 18 + Math.sin(time * 2 + i) * 3;
              let sx = centerX + Math.cos(angle) * sparkleRadius;
              let sy = centerY + Math.sin(angle) * sparkleRadius;
              ctx.save();
              ctx.beginPath();
              ctx.arc(sx, sy, 2 + Math.abs(Math.sin(time * 2 + i)) * 1.5, 0, Math.PI * 2);
              ctx.fillStyle = "rgba(255,255,255,0.85)";
              ctx.shadowColor = "#fff";
              ctx.shadowBlur = 12;
              ctx.fill();
              ctx.restore();
          }
      
          // Draw the portal core with a radial gradient for a shining effect
          let grad = ctx.createRadialGradient(centerX, centerY, baseRadius * 0.2, centerX, centerY, baseRadius);
          grad.addColorStop(0, "#fff7ff");
          grad.addColorStop(0.25, "#e0b3ff");
          grad.addColorStop(0.6, "#a259e6");
          grad.addColorStop(1, "#800080");
          ctx.beginPath();
          ctx.arc(centerX, centerY, baseRadius, 0, Math.PI * 2);
          ctx.fillStyle = grad;
          ctx.globalAlpha = 0.93;
          ctx.fill();
          ctx.globalAlpha = 1;
      
          // Draw a shining animated highlight arc
          ctx.save();
          ctx.beginPath();
          let shineAngle = time % (2 * Math.PI);
          ctx.arc(centerX, centerY, baseRadius - 4, shineAngle, shineAngle + Math.PI / 2);
          ctx.strokeStyle = "rgba(255,255,255,0.7)";
          ctx.lineWidth = 7;
          ctx.shadowColor = "#fff";
          ctx.shadowBlur = 18;
          ctx.stroke();
          ctx.restore();
      
          // Draw the portal outline
          ctx.beginPath();
          ctx.arc(centerX, centerY, baseRadius, 0, Math.PI * 2);
          ctx.strokeStyle = "violet";
          ctx.lineWidth = 5;
          ctx.shadowColor = "#fff";
          ctx.shadowBlur = 10;
          ctx.stroke();
          ctx.shadowBlur = 0;
      
          // Draw big "DUNGEONS" text above the portal, glowing
          ctx.save();
          ctx.font = "bold 28px MedievalSharp";
          ctx.textAlign = "center";
          ctx.textBaseline = "bottom";
          ctx.shadowColor = "#fff";
          ctx.shadowBlur = 16;
          ctx.fillStyle = "#fff";
          ctx.fillText("DUNGEONS", centerX, centerY - baseRadius - 24);
          ctx.restore();
      
          ctx.restore();
      }

      // UPDATED: drawShopModel – just a normal square, not a house, with more animated particles
      function drawShopModel(x, y) {
          ctx.save();
          let shopSize = 70;
          let time = Date.now() / 700;
      
          // 1. Animated golden aura (soft, subtle, square-shaped)
          for (let i = 3; i >= 1; i--) {
              ctx.save();
              ctx.globalAlpha = 0.06 * i;
              ctx.strokeStyle = `hsl(${45 + Math.sin(time + i) * 10}, 100%, 70%)`;
              ctx.lineWidth = 10 + i * 4;
              ctx.shadowColor = "#FFD700";
              ctx.shadowBlur = 10 + i * 4;
              ctx.strokeRect(x - shopSize / 2 - i * 8, y - shopSize / 2 - i * 8, shopSize + i * 16, shopSize + i * 16);
              ctx.restore();
          }
      
          // 2. Animated gold particles (float, spin, pulse)
          for (let i = 0; i < 14; i++) {
              let angle = i * (Math.PI * 2 / 14) + time * 0.8;
              let radius = shopSize / 2 + 18 + Math.sin(time * 2 + i) * 4;
              let px = x + Math.cos(angle) * radius;
              let py = y + Math.sin(angle) * radius + Math.sin(time * 2 + i) * 2;
              let pulse = 2.2 + Math.abs(Math.sin(time * 2 + i)) * 1.2;
              ctx.save();
              ctx.beginPath();
              ctx.arc(px, py, pulse, 0, Math.PI * 2);
              ctx.fillStyle = `rgba(255,215,0,${0.7 + 0.2 * Math.sin(time * 2 + i)})`;
              ctx.shadowColor = "#FFD700";
              ctx.shadowBlur = 8 + pulse * 2;
              ctx.fill();
              ctx.restore();
          }
      
          // 3. Shop square (simple, gold gradient)
          let grad = ctx.createLinearGradient(x, y - shopSize / 2, x, y + shopSize / 2);
          grad.addColorStop(0, "#FFFACD");
          grad.addColorStop(0.3, "#FFD700");
          grad.addColorStop(0.7, "#B8860B");
          grad.addColorStop(1, "#8B7500");
          ctx.save();
          ctx.beginPath();
          ctx.rect(x - shopSize / 2, y - shopSize / 2, shopSize, shopSize);
          ctx.fillStyle = grad;
          ctx.shadowColor = "#FFD700";
          ctx.shadowBlur = 10;
          ctx.fill();
          ctx.shadowBlur = 0;
          ctx.strokeStyle = "#FFF";
          ctx.lineWidth = 3;
          ctx.stroke();
          ctx.restore();
      
          // 4. "SHOP" text centered, glowing, animated color
          ctx.save();
          ctx.font = "bold 28px MedievalSharp";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.shadowColor = "#FFD700";
          ctx.shadowBlur = 12;
          ctx.fillStyle = `hsl(${45 + Math.sin(time*2)*10}, 100%, 80%)`;
          ctx.fillText("SHOP", x, y);
          ctx.restore();
      
          // 5. Subtle animated sparkles inside the square
          for (let i = 0; i < 4; i++) {
              let sparkleX = x + Math.sin(time * 2 + i) * (shopSize / 3 - 8);
              let sparkleY = y + Math.cos(time * 2 + i * 1.7) * (shopSize / 3 - 8);
              ctx.save();
              ctx.beginPath();
              ctx.arc(sparkleX, sparkleY, 1.5 + Math.abs(Math.sin(time * 3 + i)), 0, Math.PI * 2);
              ctx.fillStyle = "#fff";
              ctx.globalAlpha = 0.8;
              ctx.shadowColor = "#fff";
              ctx.shadowBlur = 6;
              ctx.fill();
              ctx.restore();
          }
      
          ctx.restore();
      }

      // UPDATED: In drawShopKeeper(), update its eye positions to follow the player.
      function drawShopKeeper(x, y) {
          // Draw shop building behind shopkeeper
          drawShopModel(x, y);
          // Draw shopkeeper model with slight bobbing
          let bobOffset = Math.sin(Date.now() / 500) * 5;
          let faceX = x;
          let faceY = y - 20 + bobOffset;
          ctx.fillStyle = "#800080";
          ctx.beginPath();
          ctx.arc(faceX, faceY, 20, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#800080";
          ctx.fillRect(x - 10, y + bobOffset, 20, 30);

          // Compute angle from Shopkeeper's face to player
          let angle = Math.atan2(player.y - faceY, player.x - faceX);
          const shopEyeOffset = 2; 
          const leftShopEyeX = faceX - 7 + Math.cos(angle) * shopEyeOffset;
          const leftShopEyeY = faceY - 5 + Math.sin(angle) * shopEyeOffset;
          const rightShopEyeX = faceX + 7 + Math.cos(angle) * shopEyeOffset;
          const rightShopEyeY = faceY - 5 + Math.sin(angle) * shopEyeOffset;

          // Draw shopkeeper eyes following the player
          // Using blink effect similar to the golem (optional: you may keep them always open)
          const shopBlinkCycle = (Date.now() % 3000) / 3000;
          const shopBlinkClosed = shopBlinkCycle < 0.1;
          if (!shopBlinkClosed) {
              ctx.fillStyle = "red";
              ctx.beginPath();
              ctx.arc(leftShopEyeX, leftShopEyeY, 3, 0, Math.PI * 2);
              ctx.fill();
              ctx.beginPath();
              ctx.arc(rightShopEyeX, rightShopEyeY, 3, 0, Math.PI * 2);
              ctx.fill();
          } else {
              ctx.strokeStyle = "red";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(leftShopEyeX - 3, leftShopEyeY);
              ctx.lineTo(leftShopEyeX + 3, leftShopEyeY);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(rightShopEyeX - 3, rightShopEyeY);
              ctx.lineTo(rightShopEyeX + 3, rightShopEyeY);
              ctx.stroke();
          }
      }

      // Add these flags at the top with other globals
      let dungeonPanelOpen = false;
      let shopPanelOpen = false;

      function openDungeonPanel(){
        if (dungeonPanelOpen) return; // Prevent reopening if already open
        dungeonPanelOpen = true;
        // Efficient rendering using document fragment
        dungeonListEl.innerHTML = "";
        let frag = document.createDocumentFragment();
        dungeons.forEach(d => {
          let li = document.createElement("li");
          li.style.display = "flex";
          li.style.justifyContent = "space-between";
          li.style.alignItems = "center";
          li.innerHTML = `<span>${d.name} (Min Level: ${d.levelReq})</span>
                          <button onclick="attemptDungeon('${d.name}', ${d.levelReq})">Select</button>`;
          frag.appendChild(li);
        });
        dungeonListEl.appendChild(frag);
        dungeonPanel.style.display = "block";
        dungeonPanel.style.left = (canvas.width/2 - 150) + "px";
        dungeonPanel.style.top = (canvas.height/2 - 150) + "px";
        // Animate in
        setTimeout(() => dungeonPanel.classList.add("open"), 10);
      }
  
      function closeDungeonPanel(){
        dungeonPanel.classList.remove("open");
        dungeonPanelOpen = false;
        // Wait for animation, then hide
        setTimeout(() => {
          if (!dungeonPanelOpen) dungeonPanel.style.display = "none";
        }, 250);
      }
  
      function attemptDungeon(name, levelReq){
        if(player.level >= levelReq){ startDungeon(name); }
        else { showNotification("Your level is too low for this dungeon!"); }
      }
  
      function startDungeon(selectedDungeonName){
        closeDungeonPanel();
        gameState = "dungeon";
        currentDungeonName = selectedDungeonName;
        currentWave = 1;
        enemies = [];
        enemiesSpawnedThisWave = 0;
        enemiesToSpawnThisWave = 3;
        player.soldiers = [];
        player.x = canvas.width/2;
        player.y = canvas.height - 50;
        showNotification("Entering " + selectedDungeonName + "! Wave " + currentWave + " begins!");
      }

      // NEW: Shop Panel Functions
      function openShopPanel(){
        if (shopPanelOpen) return; // Prevent reopening if already open
        shopPanelOpen = true;
        // Populate shop items (Fists option added manually)
        renderShopItems();
        const shopPanel = document.getElementById("shopPanel");
        shopPanel.style.display = "block";
        setTimeout(() => shopPanel.classList.add("open"), 10);
      }
      function closeShopPanel(){
        const shopPanel = document.getElementById("shopPanel");
        shopPanel.classList.remove("open");
        shopPanelOpen = false;
        setTimeout(() => {
          if (!shopPanelOpen) shopPanel.style.display = "none";
        }, 250);
      }
      function renderShopItems(){
        const listEl = document.getElementById("shopItemList");
        listEl.innerHTML = "";
        // Option to unequip (fists)
        let li = document.createElement("li");
        li.innerHTML = `<span>Fists</span>
          <button onclick="equipWeapon(null)">${!player.weapon ? "Equipped" : "Equip"}</button>`;
        listEl.appendChild(li);
        // Loop shopItems
        shopItems.forEach(item => {
          let owned = player.ownedWeapons.includes(item.name);
          let equipped = player.weapon && player.weapon.name === item.name;
          li = document.createElement("li");
          li.style.marginBottom = "8px";
          li.innerHTML = `<span>${item.name} - Cost: ${item.cost} coins<br>
                          ${item.damageMultiplier ? "Damage x" + item.damageMultiplier : ""}
                          ${item.attackSpeedMultiplier ? " | AS x" + item.attackSpeedMultiplier : ""}</span>
                          <button onclick="handleWeapon('${item.name}')">
                          ${equipped ? "Equipped" : owned ? "Equip" : "Buy"}</button>`;
          listEl.appendChild(li);
        });
      }
      function handleWeapon(itemName){
        if(itemName === "Sword" || itemName === "Dagger"){
          let item = shopItems.find(i => i.name === itemName);
          if(player.ownedWeapons.includes(item.name)){
            equipWeapon(item);
          } else {
            buyWeapon(item);
          }
        }
      }
      function buyWeapon(item){
        if(player.coins >= item.cost){
          player.coins -= item.cost;
          player.ownedWeapons.push(item.name);
          equipWeapon(item);
          updateUI();
          showNotification(item.name + " purchased and equipped!");
        } else {
          showNotification("Not enough coins to buy " + item.name);
        }
      }
      function equipWeapon(item){
        player.weapon = item;
        renderShopItems();
        updateUI();
      }
  
      /********************
       * Main Update Loop
       ********************/
      function update(timestamp){
        if(angelRuptureActive){
            ctx.fillStyle = "#fff";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#000";
            ctx.font = "48px MedievalSharp";
            let text = "Oof";
            let textWidth = ctx.measureText(text).width;
            ctx.fillText(text, (canvas.width - textWidth)/2, canvas.height/2);
            return requestAnimationFrame(update);
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Update timers and player movement...
        if(player.dodgeTimer > 0) player.dodgeTimer--;
        if(summonCooldown > 0) summonCooldown--;
        if(heavyBlowCooldown > 0) heavyBlowCooldown--;
        if(selfHealCooldown > 0) selfHealCooldown--;
        if(healOthersCooldown > 0) healOthersCooldown--;
        if(monarchSpecialCooldown > 0) monarchSpecialCooldown--;
        if(fMoveCooldown > 0) fMoveCooldown--;  // update F move cooldown
        movePlayer();
        
        if(gameState === "lobby"){
          drawLobby();  // draws background, animated grass, trees, etc.
          drawPlayer();
          drawNPC();
          checkNPCInteraction();
          // PROXIMITY DETECTION:
          let zone = lobbyZones.dungeonEntrance;
          let cx = zone.x + zone.width / 2;
          let cy = zone.y + zone.height / 2;
          let dx = player.x - cx;
          let dy = player.y - cy;
          let dist = Math.sqrt(dx * dx + dy * dy);
          let detectionRadius = (Math.min(zone.width, zone.height) / 2) * 2;
          if(dist < detectionRadius){
              openDungeonPanel();
          } else {
              // Only close if the panel is open and the player leaves the zone
              // (Optional: comment out to let user close manually)
              // if (dungeonPanelOpen) closeDungeonPanel();
          }
          // NEW: Shop zone detection. (Assume shop is drawn at (100, canvas.height -80))
          let shopCenterX = 100 + 10, shopCenterY = canvas.height -80 + 10;
          if(Math.hypot(player.x - shopCenterX, player.y - shopCenterY) < 50){
            openShopPanel();
          } else {
            // Only close if the panel is open and the player leaves the zone
            // (Optional: comment out to let user close manually)
            // if (shopPanelOpen) closeShopPanel();
          }
        } else if(gameState === "dungeon"){
          ctx.fillStyle = "#222";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#e74c3c";
          ctx.fillRect(0, 0, canvas.width, 30);
          ctx.fillStyle = "#fff";
          ctx.font = "18px MedievalSharp";
          ctx.fillText("DUNGEON", 10, 20);
          enemySpawnTimer++;
          if(enemySpawnTimer >= 90){ spawnDungeonWaveEnemies(); enemySpawnTimer = 0; }
          enemies.forEach(enemy => { enemy.move(); enemy.attackPlayer(); enemy.draw(); });
          dungeonWaveHandler();
          drawPlayer();
          drawSoldiers();
        }
        
        updateSoldiers();
        updateEffects();
        drawEffects();
        updateTransformationEffects();
        updateCooldownDisplay();
        updateUI();
        updateQuestProgress();
        grassOffset += 0.5;
        
        if(typeof syncPlayer === "function") syncPlayer();
        if(typeof drawOtherPlayers === "function") drawOtherPlayers();
        updateBlossoms();
        if(window.blossomActive) drawBlossoms();
        updateThunder();
        if(window.thunderActive) drawThunder();
        // Draw dodge trail before player
        drawDodgeTrail();
        updateDodgeTrail();
        requestAnimationFrame(update);
      }
      requestAnimationFrame(update);
  
      /********************
       * Particle Effects Functions
       ********************/
      function createEffect(x, y, color){
        effects.push({ x: x, y: y, radius: 5, color: color, alpha: 1 });
      }
      function updateEffects(){
        for(let i = effects.length - 1; i >= 0; i--){
          let eff = effects[i];
          eff.radius += 1;
          eff.alpha -= 0.03;
          if(eff.alpha <= 0) effects.splice(i, 1);
        }
      }
      function drawEffects(){
        effects.forEach(eff => {
          ctx.save();
          ctx.globalAlpha = eff.alpha;
          ctx.fillStyle = eff.color;
          ctx.beginPath();
          ctx.arc(eff.x, eff.y, eff.radius, 0, Math.PI*2);
          ctx.fill();
          ctx.restore();
        });
      }
  
      /********************
       * Draggable Panels
       ********************/
      function makeDraggable(el){
        let offsetX = 0, offsetY = 0, isDown = false;
        el.addEventListener("mousedown", (e) => {
          isDown = true;
          offsetX = e.clientX - el.offsetLeft;
          offsetY = e.clientY - el.offsetTop;
          el.style.cursor = "grabbing";
        });
        document.addEventListener("mouseup", () => {
          isDown = false;
          el.style.cursor = "move";
        });
        document.addEventListener("mousemove", (e) => {
          if(!isDown) return;
          el.style.left = (e.clientX - offsetX) + "px";
          el.style.top = (e.clientY - offsetY) + "px";
        });
      }
      makeDraggable(dungeonPanel);
      makeDraggable(document.getElementById("adminPanel"));
      makeDraggable(document.getElementById("classPanel"));
  
      /********************
       * Auto-Save Every 30 Seconds
       ********************/
      setInterval(() => { if(player.name !== "Guest") savePlayerData(); }, 30000);
  
      /********************
       * Global Announcement Sender (Admin Panel)
       ********************/
      function sendAdminAnnouncement() {
        const text = document.getElementById("announcementText").value.trim();
        const color = document.getElementById("announcementColor").value;
        const font = document.getElementById("announcementFont").value;
        if(text === "") {
          showNotification("Announcement text cannot be empty!");
          return;
        }
        if(window.socket && window.socket.connected) {
          window.socket.emit("adminAnnouncement", { text, color, font });
          showNotification("Announcement sent!");
          document.getElementById("announcementText").value = "";
        }
      }
  
      /********************
       * Class-Specific Skill Key Listeners
       ********************/
      window.addEventListener("keydown", (e) => {
        // If chat input is focused, let its own listener handle Enter.
        if(document.activeElement === chatInput) {
          // Do not register global keys when typing.
          return;
        }
        // Prevent default only for movement keys
        if(["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
          e.preventDefault();
        }
        // Record key state for game actions
        keys[e.key] = true;
        
        // Process game keys
        if(gameState === "dungeon"){
          if(e.key.toLowerCase() === "f"){
            if(player.class === "Healer") {
                selfHeal();
            } else if(player.class === "Summoner") {
                return; // summoners have no F move
            } else if(player.class === "The Goliath") {
                if(fMoveCooldown > 0) return;
                activateGoliathFMove();
                fMoveCooldown = Math.floor(66 / (player.weapon && player.weapon.attackSpeedMultiplier ? player.weapon.attackSpeedMultiplier : 1));
            } else {
                if(fMoveCooldown > 0) return;
                playerAttack();
                fMoveCooldown = Math.floor(66 / (player.weapon && player.weapon.attackSpeedMultiplier ? player.weapon.attackSpeedMultiplier : 1));
            }
          }
          if(e.key.toLowerCase() === "g"){
            if(player.class === "Fighter"){ heavyBlow(); }
            else if(player.class === "Healer"){ healOthers(); }
            else if(player.class === "The Goliath") activateGoliathGMove();
            else if((player.class === "Summoner" || player.class === "Monarch") && summonCooldown === 0){
              summonSoldiers();
              createEffect(player.x, player.y, "#ADD8E6");
              broadcastEffect(player.x, player.y, "#ADD8E6");
            }
          }
          if(player.class === "Monarch" && e.key.toLowerCase() === "h"){
            activateMonarchSpecial();
          }
          if(player.class === "The Goliath" && e.key.toLowerCase() === "h"){
            activateGoliathHMove();
          }
          if(e.key.toLowerCase() === "r") dodge();
        }
        if(e.key.toLowerCase() === "t" && player.class === "The Goliath"){
            activateGoliathTransformation();
        }
        if(e.key.toLowerCase() === "u" && player.class === "Angel"){
            activateTheRupture();
        }
      });
      window.addEventListener("keyup", (e) => { keys[e.key] = false; });
  
      /********************
       * Admin Panel and Class Panel Functions
       ********************/
      const adminUsers = ["Administrator", "Administrator 2", "Administrator 3"];
      let mutedPlayers = {};
  
      function toggleAdminPanel() {
        const panel = document.getElementById("adminPanel");
        populatePlayerList(Object.values(window.otherPlayers));
        panel.style.display = (panel.style.display === "block") ? "none" : "block";
      }
  
      function closeAdminPanel() {
        document.getElementById("adminPanel").style.display = "none";
      }
  
      function populatePlayerList(playerList) {
        const playerListEl = document.getElementById("playerList");
        playerListEl.innerHTML = "";
        playerList.forEach(p => {
          const li = document.createElement("li");
          li.innerHTML = `
            <span>${p.name}</span>
            <div>
              <button onclick="changeClass('${p.name}')">Set Class</button>
              <button onclick="toggleMute('${p.name}')">
                ${mutedPlayers[p.name] ? "Unmute" : "Mute"}
              </button>
            </div>`;
          playerListEl.appendChild(li);
        });
      }
  
      function changeClass(playerName) {
        const newClass = prompt("Enter the new class for " + playerName);
        if(newClass) {
          fetch("/changeClass", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ playerName, newClass })
          }).then(() => {
            if(window.socket && window.socket.connected){
              window.socket.emit("adminUpdate", { playerName, newClass });
            }
          });
        }
      }
  
      function toggleMute(playerName) {
        mutedPlayers[playerName] = !mutedPlayers[playerName];
        fetch("/toggleMute", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ playerName, mute: mutedPlayers[playerName] })
        }).then(() => {
          if(window.socket && window.socket.connected){
            window.socket.emit("adminUpdate", { playerName, muted: mutedPlayers[playerName] });
          }
          populatePlayerList([]);
        });
      }
  
      function toggleClassPanel() {
        const panel = document.getElementById("classPanel");
        panel.style.display = (panel.style.display === "block") ? "none" : "block";
      }
  
      function closeClassPanel() {
        document.getElementById("classPanel").style.display = "none";
      }
  
      function setClass(className) {
        player.class = className;
        updateUI();
        showNotification("Class set to " + className);
      }
  
      /********************
       * Summon Soldiers (Summoner limited to 2; Monarch now limited to 6)
       ********************/
      function summonSoldiers(){
        if(summonCooldown > 0) return;
        if(player.class !== "Summoner" && player.class !== "Monarch") return;
        let maxSoldiers = (player.class === "Summoner") ? 2 : 6; // modified: Monarch limit is now 6
        if(player.soldiers.length < maxSoldiers){
          let soldier = {
             x: player.x + (Math.random() * 30 - 15),
             y: player.y + (Math.random() * 30 - 15),
             radius: 10,
             speed: 3,
             color: (player.class === "Summoner") ? "#ADD8E6" : "#8e44ad",
             effect: (player.class === "Monarch") ? "glow" : null,
             attackCooldown: 0,
             attackMultiplier: 1,
             specialTimer: 0
          };
          player.soldiers.push(soldier);
        }
        summonCooldown = 90;
      }

      /********************
       * System Panel Functions
       ********************/
      function toggleSystem(){
        const panel = document.getElementById("systemPanel");
        panel.style.display = (panel.style.display === "block") ? "none" : "block";
        if(panel.style.display === "block"){
          document.getElementById("totalKills").innerText = totalEnemiesKilled;
          document.getElementById("totalCoins").innerText = totalCoinsCollected;
          document.getElementById("totalExp").innerText = totalExpEarned;
        }
      }

      /********************
       * Mobile Controls Event Handlers (Enhanced for pointer events)
       ********************/
      (function setupMobileControls(){
        function setKey(key, state) { keys[key] = state; }
        function addControlListeners(btnId, keyName, actionFn) {
          const btn = document.getElementById(btnId);
          if(!btn) return;
          // Touch and pointer listeners both
          btn.addEventListener("touchstart", () => setKey(keyName, true));
          btn.addEventListener("touchend", () => setKey(keyName, false));
          btn.addEventListener("touchcancel", () => setKey(keyName, false));
          btn.addEventListener("pointerdown", () => setKey(keyName, true));
          btn.addEventListener("pointerup", () => setKey(keyName, false));
          btn.addEventListener("pointercancel", () => setKey(keyName, false));
          // Optional: if an immediate action is desired (for attack/dodge/skill)
          if(typeof actionFn === "function"){
            btn.addEventListener("click", actionFn);
          }
        }
        // Directional controls
        addControlListeners("btnUp", "ArrowUp");
        addControlListeners("btnDown", "ArrowDown");
        addControlListeners("btnLeft", "ArrowLeft");
        addControlListeners("btnRight", "ArrowRight");
        
        // Action buttons (call functions on click as well)
        const btnAttack = document.getElementById("btnAttack");
        if(btnAttack){
          btnAttack.addEventListener("touchstart", () => { if(fMoveCooldown <= 0) playerAttack(); });
          btnAttack.addEventListener("pointerdown", () => { if(fMoveCooldown <= 0) playerAttack(); });
        }
        const btnDodge = document.getElementById("btnDodge");
        if(btnDodge){
          btnDodge.addEventListener("touchstart", dodge);
          btnDodge.addEventListener("pointerdown", dodge);
        }
        const btnSkill = document.getElementById("btnSkill");
        if(btnSkill){
          btnSkill.addEventListener("touchstart", () => {
            if(player.class === "Healer") healOthers();
            else if(player.class === "Fighter") heavyBlow();
            else if(player.class === "The Goliath" && fMoveCooldown <= 0) activateGoliathFMove();
          });
          btnSkill.addEventListener("pointerdown", () => {
            if(player.class === "Healer") healOthers();
            else if(player.class === "Fighter") heavyBlow();
            else if(player.class === "The Goliath" && fMoveCooldown <= 0) activateGoliathFMove();
          });
        }
      })();

      /********************
       * Event Panel Functions and Thunder functionality
       ********************/
      window.currentEvent = null; // can be "blossom", "thunder", or null
      window.blossomActive = false;
      window.thunderActive = false;
      let blossoms = [];
      let thunderDrops = [];
      let thunderBolts = [];

      function toggleEventPanel(){
        const ep = document.getElementById("eventPanel");
        ep.style.display = (ep.style.display === "block") ? "none" : "block";
      }

      function toggleBlossomEvent(){
        if(window.currentEvent === "blossom"){
          window.currentEvent = null;
          window.blossomActive = false;
        } else {
          window.currentEvent = "blossom";
          window.blossomActive = true;
          window.thunderActive = false;
        }
        if(window.socket && socket.connected){
          socket.emit("eventToggle", { event: window.currentEvent });
        }
      }

      function toggleThunderEvent(){
        if(window.currentEvent === "thunder"){
          window.currentEvent = null;
          window.thunderActive = false;
        } else {
          window.currentEvent = "thunder";
          window.thunderActive = true;
          window.blossomActive = false;
        }
        if(window.socket && socket.connected){
          socket.emit("eventToggle", { event: window.currentEvent });
        }
      }

      function updateBlossoms(){
        if(window.blossomActive && Math.random() < 0.3){
          // Only add new particles if the event is active.
          blossoms.push({ x: Math.random() * canvas.width, y: 0, speed: 2 + Math.random() * 2, alpha: 1 });
        }
        blossoms = blossoms.map(b => {
          b.y += b.speed;
          if(!window.blossomActive){
            b.alpha -= 0.01; // Fade out when event is off.
          }
          return b;
        }).filter(b => b.alpha > 0);
      }

      function drawBlossoms(){
        blossoms.forEach(b => {
          ctx.save();
          ctx.globalAlpha = b.alpha;
          ctx.fillStyle = "pink";
          ctx.beginPath();
          ctx.arc(b.x, b.y, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });
      }

      function updateThunder(){
        if(window.thunderActive && Math.random() < 0.5){
          thunderDrops.push({ x: canvas.width, y: Math.random() * canvas.height, speed: 3 + Math.random() * 2, alpha: 1 });
        }
        thunderDrops = thunderDrops.map(d => {
          d.x -= d.speed;
          if(!window.thunderActive){
            d.alpha -= 0.01;
          }
          return d;
        }).filter(d => d.alpha > 0);
        
        if(window.thunderActive && Math.random() < 0.1){
          thunderBolts.push({
            x: Math.random() * canvas.width,
            y: 0,
            dx: (Math.random() - 0.5) * 100,
            dy: canvas.height * 0.5,
            alpha: 1
          });
        }
        thunderBolts = thunderBolts.map(bolt => {
          bolt.alpha -= 0.03;
          return bolt;
        }).filter(bolt => bolt.alpha > 0);
      }

      function drawThunder(){
        thunderDrops.forEach(d => {
          ctx.save();
          ctx.globalAlpha = d.alpha;
          ctx.strokeStyle = "blue";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(d.x, d.y);
          ctx.lineTo(d.x - 20, d.y + 10);
          ctx.stroke();
          ctx.restore();
        });
        thunderBolts.forEach(bolt => {
          ctx.save();
          ctx.globalAlpha = bolt.alpha;
          ctx.strokeStyle = "blue";
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(bolt.x, bolt.y);
          ctx.lineTo(bolt.x + bolt.dx, bolt.y + bolt.dy);
          ctx.stroke();
          ctx.restore();
        });
      }

      function checkAdminForEventButton() {
        const evtBtn = document.getElementById("eventToggle");
        if(player.name === "Administrator") {
          evtBtn.style.display = "block";
        } else {
          evtBtn.style.display = "none";
        }
      }

      // UPDATED: shutdownGame function to broadcast shutdown to all players.
      function shutdownGame() {
        if(window.socket && window.socket.connected) {
          window.socket.emit("shutdown");
        }
        document.getElementById("shutdownOverlay").style.display = "flex";
      }

      // UPDATED: Increase NPC collision area (reach) to 60px diameter.
      let npcArea = { x: 75 - 30, y: 75 - 30, width: 60, height: 60 };

      // UPDATED: In drawNPC(), compute the angle from the golem to the player and draw its eyes following the player.
      function drawNPC() {
          const npcX = 75; // collision position
          const npcY = 75;
          const collisionRadius = 15;
          const modelScale = 2;
          const visualRadius = collisionRadius * modelScale;  // 30 for display

          ctx.save();
          // Create a radial gradient for a cool golem look
          const grd = ctx.createRadialGradient(npcX, npcY, visualRadius * 0.3, npcX, npcY, visualRadius);
          grd.addColorStop(0, "#ffd700");
          grd.addColorStop(1, "#b8860b");
          ctx.shadowBlur = 20;
          ctx.shadowColor = "gold";
          ctx.beginPath();
          ctx.arc(npcX, npcY, visualRadius, 0, Math.PI * 2);
          ctx.fillStyle = grd;
          ctx.fill();
          ctx.restore();

          // Compute angle from NPC to player for eye movement
          let angle = Math.atan2(player.y - npcY, player.x - npcX);
          const eyeOffset = 2; // small tweak to shift eyes in the direction of the player
          const leftEyeX = npcX - 10 + Math.cos(angle) * eyeOffset;
          const leftEyeY = npcY - 5 + Math.sin(angle) * eyeOffset;
          const rightEyeX = npcX + 10 + Math.cos(angle) * eyeOffset;
          const rightEyeY = npcY - 5 + Math.sin(angle) * eyeOffset;

          // More realistic blinking: using a cycle (eyes closed for 10% of a 3-second cycle)
          const blinkCycle = (Date.now() % 3000) / 3000;
          const blinkClosed = blinkCycle < 0.1;

          ctx.save();
          if (blinkClosed) {
              // Draw closed eyes as short horizontal lines following the player direction.
              ctx.strokeStyle = "#ff4500";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(leftEyeX - 5, leftEyeY);
              ctx.lineTo(leftEyeX + 5, leftEyeY);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(rightEyeX - 5, rightEyeY);
              ctx.lineTo(rightEyeX + 5, rightEyeY);
              ctx.stroke();
          } else {
              // Draw open eyes with glowing effect.
              ctx.fillStyle = "#ff4500";
              ctx.beginPath();
              ctx.arc(leftEyeX, leftEyeY, 5, 0, Math.PI * 2);
              ctx.fill();
              ctx.beginPath();
              ctx.arc(rightEyeX, rightEyeY, 5, 0, Math.PI * 2);
              ctx.fill();
          }
          ctx.restore();

          ctx.save();
          ctx.fillStyle = "#fff";
          ctx.font = "bold 18px MedievalSharp";
          let title = "The Golem is temporarily Disabled";
          let titleWidth = ctx.measureText(title).width;
          ctx.fillText(title, npcX - titleWidth / 2, npcY - visualRadius - 15);
          ctx.restore();
      }

      // UPDATED: Update checkNPCInteraction() to use the enlarged npcArea.
      // Also ensure the NPC dialogue opens only once by using a flag.
      function checkNPCInteraction() {
        if (
          player.x + player.radius > npcArea.x &&
          player.x - player.radius < npcArea.x + npcArea.width &&
          player.y + player.radius > npcArea.y &&
          player.y - player.radius < npcArea.y + npcArea.height &&
          !window.npcDialogueOpened
        ) {
          window.npcDialogueOpened = true;
          openNPCDialogue();
        }
      }

      // UPDATED: In openNPCDialogue(), change the dialogue message
      function openNPCDialogue() {
          // Center the dialogue on the player's screen
          const dialogue = document.getElementById("npcDialogue");
          const message = document.getElementById("npcMessage");
          const options = document.getElementById("npcOptions");
          if (dialogue.style.display === "block") return;
          dialogue.style.top = "50%";
          dialogue.style.left = "50%";
          dialogue.style.transform = "translate(-50%, -50%)";
          dialogue.style.display = "block";
          message.innerText = "The Golem is temporarily Disabled";
          options.innerHTML = "";
          const okBtn = document.createElement("button");
          okBtn.innerText = "OK";
          okBtn.style.background = "#27ae60";
          okBtn.style.border = "none";
          okBtn.style.color = "#fff";
          okBtn.style.padding = "10px 20px";
          okBtn.style.borderRadius = "4px";
          okBtn.onclick = function () {
              dialogue.style.display = "none";
              window.npcDialogueOpened = false;
          };
          options.appendChild(okBtn);
      }

      /* UPDATED: In openQuestPanel(), initialize a quest with proper progress counters and reset progress */
      function openQuestPanel() {
        const questPanel = document.getElementById("questPanel");
        questPanel.style.display = "block";
        questPanel.querySelector("h2").innerText = "Quest Board";
        // Initialize quest objectives and progress.
        player.quest = {
          objectives: {
            enemies: 100,
            dungeons: 5,
            coins: 1000
          },
          progress: {
            enemies: totalEnemiesKilled || 0,
            dungeons: 0,
            coins: player.coins || 0
          },
          completed: false,
          claimed: false
        };
        document.getElementById("questEnemies").innerText = player.quest.progress.enemies + "/100";
        document.getElementById("questDungeons").innerText = "0/5";
        document.getElementById("questCoins").innerText = player.quest.progress.coins + "/1000";
      }

      /* UPDATED: In updateQuestProgress(), update each objective from global counters.
         When all objectives are met, modify the quest panel to show “Quest Completed! Claim Reward” */
      function updateQuestProgress() {
        if (!player.quest || player.quest.completed) return;
        // Update enemy kills and coins from global counters
        player.quest.progress.enemies = Math.min(totalEnemiesKilled, player.quest.objectives.enemies);
        player.quest.progress.coins = Math.min(player.coins, player.quest.objectives.coins);
        // (Dungeon clearance is updated separately; default to 0 if not set)
        if (player.quest.progress.dungeons === undefined) player.quest.progress.dungeons = 0;
        
        document.getElementById("questEnemies").innerText = player.quest.progress.enemies + "/100";
        document.getElementById("questDungeons").innerText = player.quest.progress.dungeons + "/5";
        document.getElementById("questCoins").innerText = player.quest.progress.coins + "/1000";
        
        if (
          player.quest.progress.enemies >= player.quest.objectives.enemies &&
          player.quest.progress.dungeons >= player.quest.objectives.dungeons &&
          player.quest.progress.coins >= player.quest.objectives.coins
        ) {
          player.quest.completed = true;
          showGoldenAchievement("Quest Completed! Claim Your Reward!");
          // Change quest panel actions: hide Accept/Discard and add Claim button.
          const actionsDiv = questPanel.querySelector(".questActions");
          actionsDiv.innerHTML = "";
          const claimBtn = document.createElement("button");
          claimBtn.innerText = "Claim Reward";
          claimBtn.style.background = "#27ae60";
          claimBtn.style.border = "none";
          claimBtn.style.color = "#fff";
          claimBtn.style.padding = "10px 20px";
          claimBtn.style.borderRadius = "4px";
          claimBtn.onclick = function () {
            showNotification("Reward Claimed!");
            player.quest.claimed = true;
            questPanel.style.display = "none";
          };
          actionsDiv.appendChild(claimBtn);
        }
      }

      // UPDATED: Enhance openQuestPanel() so that the panel heading becomes "Quest Board" and a basic quest is set.
      function openQuestPanel() {
        const questPanel = document.getElementById("questPanel");
        questPanel.style.display = "block";
        questPanel.querySelector("h2").innerText = "Quest Board";
        // Set up a basic quest so updateQuestProgress can work.
        player.quest = {
          objectives: {
            enemies: 100,
            dungeons: 5,
            coins: 1000
          },
          progress: {
            enemies: 0,
            dungeons: 0,
            coins: 0
          },
          completed: false,
          claimed: false
        };
        document.getElementById("questEnemies").innerText = "0/100";
        document.getElementById("questDungeons").innerText = "0/5";
        document.getElementById("questCoins").innerText = "0/1000";
      }

      // NEW: Function to show a golden achievement animation
      function showGoldenAchievement(text) {
        const achievement = document.createElement("div");
        achievement.innerText = text;
        achievement.style.position = "fixed";
        achievement.style.top = "30%";
        achievement.style.left = "50%";
        achievement.style.transform = "translate(-50%, -50%)";
        achievement.style.fontSize = "48px";
        achievement.style.fontWeight = "bold";
        achievement.style.color = "gold";
        achievement.style.zIndex = 2200;
        achievement.style.opacity = 1;
        document.body.appendChild(achievement);
        // Fade out animation
        let fade = setInterval(() => {
          achievement.style.opacity -= 0.05;
          if(achievement.style.opacity <= 0){
            clearInterval(fade);
            achievement.remove();
          }
        }, 100);
      }

      // NEW: Quest Panel button handlers
      document.getElementById("acceptQuest").onclick = function() {
        // When accepted, simply close the panel; progress will update in game loop.
        document.getElementById("questPanel").style.display = "none";
      };
      document.getElementById("discardQuest").onclick = function() {
        player.quest = null;
        document.getElementById("questPanel").style.display = "none";
      };

      // NEW: Function to open Redeemed Classes list (for claiming reward)
      function openRedeemedClasses() {
        const listDiv = document.getElementById("redeemedList");
        listDiv.innerHTML = "";
        if(player.quest && player.quest.completed && !player.quest.claimed) {
          // Add Mage class as available reward.
          let div = document.createElement("div");
          div.innerText = "Mage";
          let chooseBtn = document.createElement("button");
          chooseBtn.innerText = "Choose";
          chooseBtn.onclick = function() {
            player.class = "Mage";
            // Setup Mage abilities:
            player.fireballCooldown = 0;
            player.elementalWindCooldown = 0;
            showNotification("Mage class equipped with Fire Ball and Elemental Wind!");
            document.getElementById("redeemedClasses").style.display = "none";
          };
          div.appendChild(chooseBtn);
          listDiv.appendChild(div);
        }
        document.getElementById("redeemedClasses").style.display = "block";
      }

      // Meteor Event Globals
      window.meteorActive = false;
      let meteorPhase = 0;
      let meteorStartTime = 0;
      let meteorFlashAlpha = 0;
      let meteorShockwaves = [];
      let meteorLittleMeteors = [];
      let meteorBigMeteor = null;
      let meteorTextAlpha = 0;
      let meteorTextTimer = 0;

      // Add Meteor to event toggles
      function toggleMeteorEvent() {
        if(window.currentEvent === "meteor"){
          window.currentEvent = null;
          window.meteorActive = false;
        } else {
          window.currentEvent = "meteor";
          window.meteorActive = true;
          window.blossomActive = false;
          window.thunderActive = false;
          startMeteorEvent();
          if(window.socket && socket.connected){
            socket.emit("eventToggle", { event: "meteor" });
          }
        }
      }

      // Listen for meteor event from multiplayer (if present)
      if (window.socket) {
        window.socket.on && window.socket.on("eventToggle", function(data) {
          if(data.event === "meteor"){
            window.currentEvent = "meteor";
            window.meteorActive = true;
            window.blossomActive = false;
            window.thunderActive = false;
            startMeteorEvent();
          }
        });
      }

      // Start Meteor Event
      function startMeteorEvent() {
        meteorPhase = 0;
        meteorStartTime = Date.now();
        meteorFlashAlpha = 0;
        meteorShockwaves = [];
        meteorLittleMeteors = [];
        meteorBigMeteor = null;
        meteorTextAlpha = 1;
        meteorTextTimer = 0;
        // Bring everyone to lobby
        gameState = "lobby";
        // Show animated red text
        showMeteorImminentText();
      }

      // Show animated red text "Meteor Imminent!"
      function showMeteorImminentText() {
        meteorTextAlpha = 1;
        meteorTextTimer = 0;
      }

      // Draw Meteor Event (call in main update loop)
      function drawMeteorEvent() {
        let now = Date.now();
        let elapsed = (now - meteorStartTime) / 1000;

        // 1. Show animated red text for 2 seconds
        if (meteorTextAlpha > 0) {
          ctx.save();
          ctx.globalAlpha = Math.max(0, meteorTextAlpha);
          ctx.font = "bold 56px MedievalSharp";
          ctx.fillStyle = "#ff2222";
          ctx.shadowColor = "#ff0000";
          ctx.shadowBlur = 18;
          ctx.textAlign = "center";
          ctx.fillText("Meteor Imminent!", canvas.width/2, canvas.height/2 - 120);
          ctx.restore();
          meteorTextTimer += 1/60;
          if (meteorTextTimer > 2) meteorTextAlpha -= 0.03;
        }

        // 2. Big meteor falls from sky (first 1.5s)
        if (elapsed < 1.5) {
          let t = Math.min(1, elapsed / 1.5);
          let mx = canvas.width/2;
          let my = -100 + (canvas.height/2 + 60 + 100) * t;
          // Glowing white ball
          ctx.save();
          let grad = ctx.createRadialGradient(mx, my, 0, mx, my, 40);
          grad.addColorStop(0, "#fff");
          grad.addColorStop(0.5, "#fff");
          grad.addColorStop(1, "#ccc");
          ctx.beginPath();
          ctx.arc(mx, my, 40, 0, Math.PI*2);
          ctx.fillStyle = grad;
          ctx.shadowColor = "#fff";
          ctx.shadowBlur = 40;
          ctx.fill();
          ctx.restore();
          // Meteor trail
          ctx.save();
          ctx.globalAlpha = 0.5;
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 10;
          ctx.beginPath();
          ctx.moveTo(mx, my-80);
          ctx.lineTo(mx, my);
          ctx.stroke();
          ctx.restore();
          return;
        }

        // 3. Big flashbang shockwave at center (at 1.5s)
        if (elapsed >= 1.5 && meteorPhase === 0) {
          meteorPhase = 1;
          meteorFlashAlpha = 1;
          meteorShockwaves.push({x:canvas.width/2, y:canvas.height/2+60, r:40, alpha:1, t:0});
          // Play sound or effect if desired
        }

        // 4. Animate shockwave
        meteorShockwaves.forEach(sw => {
          ctx.save();
          ctx.globalAlpha = sw.alpha;
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 12;
          ctx.beginPath();
          ctx.arc(sw.x, sw.y, sw.r, 0, Math.PI*2);
          ctx.stroke();
          ctx.restore();
          sw.r += 18;
          sw.alpha -= 0.04;
        });
        meteorShockwaves = meteorShockwaves.filter(sw => sw.alpha > 0);

        // 5. Flashbang (white overlay)
        if (meteorFlashAlpha > 0) {
          ctx.save();
          ctx.globalAlpha = meteorFlashAlpha;
          ctx.fillStyle = "#fff";
          ctx.fillRect(0,0,canvas.width,canvas.height);
          ctx.restore();
          meteorFlashAlpha -= 0.04;
        }

        // 6. Little meteors from all sides (from 1.7s to 3.2s)
        if (elapsed > 1.7 && elapsed < 3.2) {
          if (Math.random() < 0.25) {
            // Spawn a little meteor from a random edge
            let edge = Math.floor(Math.random()*4);
            let mx, my, dx, dy;
            let cx = canvas.width/2, cy = canvas.height/2+60;
            if (edge === 0) { // top
              mx = Math.random()*canvas.width; my = -30;
            } else if (edge === 1) { // bottom
              mx = Math.random()*canvas.width; my = canvas.height+30;
            } else if (edge === 2) { // left
              mx = -30; my = Math.random()*canvas.height;
            } else { // right
              mx = canvas.width+30; my = Math.random()*canvas.height;
            }
            let angle = Math.atan2(cy-my, cx-mx);
            dx = Math.cos(angle)*10;
            dy = Math.sin(angle)*10;
            meteorLittleMeteors.push({x:mx, y:my, dx, dy, hit:false});
          }
        }

        // 7. Animate little meteors
        meteorLittleMeteors.forEach(m => {
          if (!m.hit) {
            m.x += m.dx;
            m.y += m.dy;
            // Draw meteor
            ctx.save();
            let grad = ctx.createRadialGradient(m.x, m.y, 0, m.x, m.y, 14);
            grad.addColorStop(0, "#fff");
            grad.addColorStop(1, "#bbb");
            ctx.beginPath();
            ctx.arc(m.x, m.y, 14, 0, Math.PI*2);
            ctx.fillStyle = grad;
            ctx.shadowColor = "#fff";
            ctx.shadowBlur = 18;
            ctx.fill();
            ctx.restore();
            // Trail
            ctx.save();
            ctx.globalAlpha = 0.4;
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(m.x-m.dx*2, m.y-m.dy*2);
            ctx.lineTo(m.x, m.y);
            ctx.stroke();
            ctx.restore();
            // If hit center
            let d = Math.hypot(m.x-canvas.width/2, m.y-(canvas.height/2+60));
            if (d < 24) {
              m.hit = true;
              meteorShockwaves.push({x:canvas.width/2, y:canvas.height/2+60, r:24, alpha:1, t:0});
              meteorFlashAlpha = 0.7;
            }
          }
        });
        meteorLittleMeteors = meteorLittleMeteors.filter(m => !m.hit || Math.random()>0.1);

        // 8. After 3.2s, spawn big meteor
        if (elapsed > 3.2 && meteorPhase === 1) {
          meteorPhase = 2;
          meteorBigMeteor = {x:canvas.width/2, y:-120, vy:32, hit:false};
        }

        // 9. Animate big meteor
        if (meteorBigMeteor && !meteorBigMeteor.hit) {
          meteorBigMeteor.y += meteorBigMeteor.vy;
          // Draw big meteor
          ctx.save();
          let grad = ctx.createRadialGradient(meteorBigMeteor.x, meteorBigMeteor.y, 0, meteorBigMeteor.x, meteorBigMeteor.y, 70);
          grad.addColorStop(0, "#fff");
          grad.addColorStop(1, "#f00");
          ctx.beginPath();
          ctx.arc(meteorBigMeteor.x, meteorBigMeteor.y, 70, 0, Math.PI*2);
          ctx.fillStyle = grad;
          ctx.shadowColor = "#fff";
          ctx.shadowBlur = 60;
          ctx.fill();
          ctx.restore();
          // Trail
          ctx.save();
          ctx.globalAlpha = 0.5;
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 18;
          ctx.beginPath();
          ctx.moveTo(meteorBigMeteor.x, meteorBigMeteor.y-120);
          ctx.lineTo(meteorBigMeteor.x, meteorBigMeteor.y);
          ctx.stroke();
          ctx.restore();
          // Hit center
          if (meteorBigMeteor.y > canvas.height/2+60) {
            meteorBigMeteor.hit = true;
            meteorFlashAlpha = 1.2;
            meteorShockwaves.push({x:canvas.width/2, y:canvas.height/2+60, r:70, alpha:1, t:0});
          }
        }

        // 10. Final whiteout
        if (meteorBigMeteor && meteorBigMeteor.hit && meteorFlashAlpha > 0) {
          ctx.save();
          ctx.globalAlpha = Math.min(1, meteorFlashAlpha);
          ctx.fillStyle = "#fff";
          ctx.fillRect(0,0,canvas.width,canvas.height);
          ctx.restore();
          meteorFlashAlpha -= 0.03;
        }

        // 11. End event after whiteout
        if (meteorBigMeteor && meteorBigMeteor.hit && meteorFlashAlpha <= 0) {
          window.meteorActive = false;
          window.currentEvent = null;
          meteorPhase = 0;
          // Optionally: reset all meteor variables here
        }
      }

      // --- Patch main update loop to call drawMeteorEvent if active ---
      const _origUpdate = update;
      update = function(timestamp) {
        // ...existing code...
        if (window.meteorActive) {
          drawMeteorEvent();
          requestAnimationFrame(update);
          return;
        }
        _origUpdate(timestamp);
      };
    </script>
  </body>
</html>